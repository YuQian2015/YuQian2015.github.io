<!DOCTYPE html><html><head><meta charset="utf-8"><title>摸鱼前端 | Moyufed</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu-site-verification" content="bWMteHRHG2"><meta name="description" content="分享有趣好玩的前端技术"><meta name="keywords" content="前端,全栈,分享,nodejs,webpack,linux"><meta property="og:type" content="website"><meta property="og:title" content="摸鱼前端 | Moyufed"><meta property="og:url" content="http://blog.moyufed.com/index.html"><meta property="og:site_name" content="摸鱼前端 | Moyufed"><meta property="og:description" content="分享有趣好玩的前端技术"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="摸鱼前端 | Moyufed"><meta name="twitter:description" content="分享有趣好玩的前端技术"><link rel="alternate" href="/atom.xml" title="摸鱼前端 | Moyufed" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">摸鱼前端 | Moyufed</a></h1><h2 id="subtitle-wrap"><a href="/" id="subtitle">分享有趣好玩的前端技术，游戏研究猿，欢迎交流，一起来摸鱼。</a></h2></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives">Archives</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="搜索"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.moyufed.com"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-【前端开发日常-3】让create-react-app支持-装饰器语法" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/" class="article-date"><time datetime="2020-09-17T00:52:39.000Z" itemprop="datePublished">2020-09-16</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/">【前端开发日常 - 3】让create-react-app支持@装饰器语法</a></h1></header><div class="article-entry" itemprop="articleBody"><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>目前在做的一个 react 项目是使用 <code>create-react-app</code> 创建的，我需要在里面使用 <code>mobx</code> 和 <code>mobx-react</code> 管理状态，<code>mobx-react</code> 支持使用装饰器的方式来书写，而 <code>create-react-app</code> 目前还没有内置的装饰器支持，所以在启动项目时会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Support for the experimental syntax 'decorators-legacy' isn't currently enabled</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener"><code>react-app-rewired</code></a> 修改 <code>create-react-app</code> 的配置，使其支持装饰器语法。</p><blockquote><p>此工具可以在不 ‘eject’ 也不创建额外 react-scripts 的情况下修改 create-react-app 内置的 webpack 配置，然后你将拥有 create-react-app 的一切特性，且可以根据你的需要去配置 webpack 的 plugins, loaders 等。</p></blockquote><h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><p>检查 babel 版本，我们可以打开 <code>node_modules/react-scripts/package.json</code> 查看安装的 babel 版本，针对不同的版本安装不同插件：</p><ul><li><p>babel 6 安装 <code>babel-plugin-transform-decorators-legacy</code></p></li><li><p>babel 7 安装 <code>@babel/plugin-proposal-decorators</code></p></li></ul><p>可以在 <a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy" target="_blank" rel="noopener">babel-plugin-transform-decorators-legacy</a> 查看版本区别。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>安装 <code>react-app-rewired</code> 以及 babel 插件，本人使用babel 7，所以安装 <code>@babel/plugin-proposal-decorators</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn add --dev react-app-rewired</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yarn add --dev @babel/plugin-proposal-decorators</span></span><br></pre></td></tr></table></figure><p>修改 <code>package.json</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">    <span class="string">"eject"</span>: <span class="string">"react-scripts eject"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意：由于 <code>react-app-rewire</code> v2.0 以上版本已经移除了 <code>getBabelLoader</code> ，需要使用 <a href="https://github.com/arackaf/customize-cra" target="_blank" rel="noopener"><code>customize-cra</code></a> 库的 <code>addBabelPlugins</code> 方法代替。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The "getBabelLoader" helper has been deprecated as of v2.0. You can use customize-cra plugins in replacement - https://github.com/arackaf/customize-cra#available-plugins</span><br></pre></td></tr></table></figure><h3 id="安装-customize-cra"><a href="#安装-customize-cra" class="headerlink" title="安装 customize-cra"></a>安装 customize-cra</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn add --dev customize-cra</span></span><br></pre></td></tr></table></figure><p>在项目根目录新增 <code>config-overrides.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; override, addDecoratorsLegacy, disableEsLint &#125; = <span class="built_in">require</span>(<span class="string">"customize-cra"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">    addDecoratorsLegacy(),</span><br><span class="line">    disableEsLint()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn start</span></span><br></pre></td></tr></table></figure><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://www.jianshu.com/p/23d9ce9ac718" target="_blank" rel="noopener">https://www.jianshu.com/p/23d9ce9ac718</a><br><a href="https://www.cnblogs.com/so-letitgo/p/10010428.html" target="_blank" rel="noopener">https://www.cnblogs.com/so-letitgo/p/10010428.html</a><br><a href="https://www.jianshu.com/p/b16f7598c859" target="_blank" rel="noopener">https://www.jianshu.com/p/b16f7598c859</a><br><a href="https://www.jianshu.com/p/b841aee4745f" target="_blank" rel="noopener">https://www.jianshu.com/p/b841aee4745f</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/" data-id="ckf55gcu500082svy9vncltg6" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-通过rel-preload进行内容预加载" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/14/通过rel-preload进行内容预加载/" class="article-date"><time datetime="2020-09-14T07:14:07.000Z" itemprop="datePublished">2020-09-13</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/14/通过rel-preload进行内容预加载/">通过rel=preload进行内容预加载</a></h1></header><div class="article-entry" itemprop="articleBody"><p>更多详情可以参考，参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener">MDN文档</a> 。</p><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>最近遇到的问题：</p><ul><li>一个页面加载主要逻辑 <code>main.js</code> ，该文件很大，设计很多业务代码，并且依赖部分 JavaScript 插件，在 <code>main.js</code> 执行之前需要确保 JavaScript 插件加载完成。</li><li>需要确保 <code>main.js</code> 以较快的速度加载，不能因为 <code>js</code> 文件的加载顺序影响首页渲染时间。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>预加载 <code>main.js</code> 文件，等到 JavaScript 插件加载完成之后生效。</li></ul><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>在浏览器的主渲染机制介入前预先加载资源。</li><li>不阻塞页面的初步渲染，进而提升性能。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link" target="_blank" rel="noopener"><code>&lt;link&gt;</code></a> 元素的 <code>rel</code> 属性的属性值 <code>preload</code> 能够让你在HTML页面中 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head" target="_blank" rel="noopener"><code>&lt;head&gt;</code></a> 元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。</p><h3 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h3><p><code>&lt;link&gt;</code> 标签最常见的应用情形就是被用来加载CSS文件，进而装饰页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"styles/main.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="预加载使用"><a href="#预加载使用" class="headerlink" title="预加载使用"></a>预加载使用</h3><p>使用<code>preload</code>作为<code>rel</code>属性的属性值，你还需要通过 <code>href</code> 和 <code>as</code> 属性指定需要被预加载资源的资源路径及其类型。简单示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS and CSS preload example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"main.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>bouncing balls<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，我们预加载了CSS和JavaScript文件，所以在随后的页面渲染中，一旦需要使用它们，它们就会立即可用。</p><p><code>preload</code> 还有许多其他好处。使用 <code>as</code> 来指定将要预加载的内容的类型，将使得浏览器能够：</p><ul><li><p>更精确地优化资源加载优先级。</p></li><li><p>匹配未来的加载需求，在适当的情况下，重复利用同一资源。</p></li><li><p>为资源应用正确的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener">内容安全策略</a>。</p></li><li><p>为资源设置正确的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept" target="_blank" rel="noopener"><code>Accept</code></a> 请求头。</p></li></ul><h3 id="可以被预加载的资源"><a href="#可以被预加载的资源" class="headerlink" title="可以被预加载的资源"></a>可以被预加载的资源</h3><p>许多类型的内容都可以被预加载，一些主要可用的 <code>as</code> 属性值列举如下：</p><ul><li><code>audio</code>：音频文件。</li><li><code>document</code>： 一个将要被嵌入到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/frame" target="_blank" rel="noopener"><code>&lt;frame&gt;</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener"><code>&lt;iframe&gt;</code></a> 内部的HTML文档。</li><li><code>embed</code>：一个将要被嵌入到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed" target="_blank" rel="noopener"><code>&lt;embed&gt;</code></a> 元素内部的资源。</li><li><code>fetch</code>：那些将要通过 fetch 和 XHR 请求来获取的资源，比如一个 ArrayBuffer 或 JSON 文件。</li><li><code>font</code>： 字体文件。</li><li><code>image</code>:：图片文件。</li><li><code>object</code>：一个将会被嵌入到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed" target="_blank" rel="noopener"><code>&lt;embed&gt;</code></a> 元素内的文件。</li><li><code>script</code>： JavaScript文件。</li><li><code>style</code>：样式表。</li><li><code>track</code>：WebVTT文件。</li><li><code>worker</code>：一个 JavaScript 的 web worker 或 shared worker 。</li><li><code>video</code>：视频文件。</li></ul><h3 id="包含一个MIME类型"><a href="#包含一个MIME类型" class="headerlink" title="包含一个MIME类型"></a>包含一个MIME类型</h3><p><code>&lt;link&gt;</code> 元素可以接受一个 <code>type</code> 属性，在浏览器进行预加载的时候，浏览器将使用 <code>type</code> 属性来判断它是否支持这一资源，如果浏览器支持这一类型资源的预加载，下载将会开始，否则便对其加以忽略。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Video preload example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"sintel-short.mp4"</span> <span class="attr">as</span>=<span class="string">"video"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sintel-short.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sintel-short.webm"</span> <span class="attr">type</span>=<span class="string">"video/webm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn't support HTML5 video. Here is a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"sintel-short.mp4"</span>&gt;</span>link to the video<span class="tag">&lt;/<span class="name">a</span>&gt;</span> instead.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个实例中，支持MP4格式的浏览器将仅预加载并使用MP4资源，以使得视频播放器的表现尽可能的流畅，或者说，为用户提供更好的响应。而不支持MP4格式的浏览器仍然能够加载视频的WebM版本，但无法体验到预加载带来的良好体验。这个例子展示了预加载机制如何与渐进式增强的哲学进行有机的结合，可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener">MDN文档</a> 的详细介绍。</p><h3 id="脚本预加载"><a href="#脚本预加载" class="headerlink" title="脚本预加载"></a>脚本预加载</h3><p>预加载但不执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preloadLink = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">preloadLink.href = <span class="string">"myscript.js"</span>;</span><br><span class="line">preloadLink.rel = <span class="string">"preload"</span>;</span><br><span class="line">preloadLink.as = <span class="string">"script"</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(preloadLink);</span><br></pre></td></tr></table></figure><p>需要执行时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preloadedScript = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">preloadedScript.src = <span class="string">"myscript.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(preloadedScript);</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/14/通过rel-preload进行内容预加载/" data-id="ckf55gcuo000i2svy886p6e14" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-HTTP状态码参考" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/02/HTTP状态码参考/" class="article-date"><time datetime="2020-09-02T00:04:04.000Z" itemprop="datePublished">2020-09-01</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/02/HTTP状态码参考/">HTTP状态码参考</a></h1></header><div class="article-entry" itemprop="articleBody"><h3 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h3><table><thead><tr><th>已定义范围</th><th>分类</th><th></th></tr></thead><tbody><tr><td>1XX</td><td>100-101</td><td>信息提示</td></tr><tr><td>2XX</td><td>200-206</td><td>成功</td></tr><tr><td>3XX</td><td>300-305</td><td>重定向</td></tr><tr><td>4XX</td><td>400-415</td><td>客户端错误</td></tr><tr><td>5XX</td><td>500-505</td><td>服务器错误</td></tr></tbody></table><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><table><thead><tr><th><strong>200 OK 服务器成功处理了请求</strong></th></tr></thead><tbody><tr><td>301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td></tr><tr><td>304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存</td></tr><tr><td><strong>404 Not Found 未找到资源</strong></td></tr><tr><td>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</td></tr></tbody></table><h3 id="1XX-信息性状态码"><a href="#1XX-信息性状态码" class="headerlink" title="1XX 信息性状态码"></a>1XX 信息性状态码</h3><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>100</td><td>Continue(继续)</td><td>收到了请求的起始部分，客户端应该继续请求</td><td></td></tr><tr><td>101</td><td>Switching Protocols（切换协议）</td><td>服务器正根据客户端的指示将协议切换成Update Header列出的协议</td></tr></tbody></table><h3 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a>2XX 成功状态码</h3><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>服务器成功处理了请求（这个是我们见到最多的）</td><td>HTTP协议详解-200</td></tr><tr><td>201</td><td>Created（已创建）</td><td>对于那些要服务器创建对象的请求来说，资源已创建完毕。</td><td></td></tr><tr><td>202</td><td>Accepted（已接受）</td><td>请求已接受， 但服务器尚未处理</td><td></td></tr><tr><td>203</td><td>Non-Authoritative Information（非权威信息）</td><td>服务器已将事务成功处理，只是实体Header包含的信息不是来自原始服务器，而是来自资源的副本。</td><td></td></tr><tr><td>204</td><td>No Content(没有内容)</td><td>Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）</td><td>状态码204</td></tr><tr><td>205</td><td>Reset Content(重置内容)</td><td>另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的HTML表单。</td><td></td></tr><tr><td>206</td><td>Partial Content（部分内容）</td><td>部分请求成功</td><td>状态码206</td></tr></tbody></table><h3 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a>3XX 重定向状态码</h3><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices（多项选择）</td><td>客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了</td><td></td></tr><tr><td>301</td><td>Moved Permanently（永久移除)</td><td>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td><td>状态码301</td></tr><tr><td>302</td><td>Found（已找到）</td><td>与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP request</td><td>HTTP协议详解-302</td></tr><tr><td>303</td><td>See Other（参见其他）</td><td>类似302</td><td></td></tr><tr><td>304</td><td>Not Modified（未修改）</td><td>客户的缓存资源是最新的， 要客户端使用缓存</td><td>HTTP协议之缓存-304</td></tr><tr><td>305</td><td>Use Proxy（使用代理）</td><td>必须通过代理访问资源， 代理的地址在Response 的Location中</td><td></td></tr><tr><td>306</td><td>未使用</td><td>这个状态码当前没使用</td><td></td></tr><tr><td>307</td><td>Temporary Redirect（临时重定向</td><td>类似302</td></tr></tbody></table><h3 id="4XX客户端错误状态码"><a href="#4XX客户端错误状态码" class="headerlink" title="4XX客户端错误状态码"></a>4XX客户端错误状态码</h3><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>400</td><td>Bad Request（坏请求）</td><td>告诉客户端，它发送了一个错误的请求。</td><td>状态码400</td></tr><tr><td>401</td><td>Unauthorized（未授权）</td><td>需要客户端对自己认证</td><td>HTTP协议之基本认证-401</td></tr><tr><td>402</td><td>Payment Required（要求付款）</td><td>这个状态还没被使用， 保留给将来用</td><td></td></tr><tr><td>403</td><td>Forbidden（禁止）</td><td>请求被服务器拒绝了</td><td>状态码403</td></tr><tr><td>404</td><td>Not Found（未找到）</td><td>未找到资源</td><td>HTTP协议详解-404</td></tr><tr><td>405</td><td>Method Not Allowed（不允许使用的方法）</td><td>不支持该Request的方法。</td><td>状态码405</td></tr><tr><td>406</td><td>Not Acceptable（无法接受）</td><td></td><td></td></tr><tr><td>407</td><td>Proxy Authentication Required(要求进行代理认证)</td><td>与状态码401类似， 用于需要进行认证的代理服务器</td><td>HTTP协议之代理-407</td></tr><tr><td>408</td><td>Request Timeout（请求超时）</td><td>如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接</td><td></td></tr><tr><td>409</td><td>Conflict（冲突）</td><td>发出的请求在资源上造成了一些冲突</td><td></td></tr><tr><td>410</td><td>Gone（消失了）</td><td>服务器曾经有这个资源，现在没有了， 与状态码404类似</td><td></td></tr><tr><td>411</td><td>Length Required（要求长度指示）</td><td>服务器要求在Request中包含Content-Length。</td><td>状态码411</td></tr><tr><td>412</td><td>Precondition Failed（先决条件失败）</td><td></td><td></td></tr><tr><td>413</td><td>Request Entity Too Large（请求实体太大）</td><td>客户端发送的实体主体部分比服务器能够或者希望处理的要大</td><td>状态码413</td></tr><tr><td>414</td><td>Request URI Too Long（请求URI太长）</td><td>客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度</td><td>状态码414</td></tr><tr><td>415</td><td>Unsupported Media Type（不支持的媒体类型）</td><td>服务器无法理解或不支持客户端所发送的实体的内容类型</td><td></td></tr><tr><td>416</td><td>Requested Range Not Satisfiable（所请求的范围未得到满足）</td><td></td><td></td></tr><tr><td>417</td><td>Expectation Failed（无法满足期望）</td><td></td></tr></tbody></table><h3 id="5XX服务器错误状态码"><a href="#5XX服务器错误状态码" class="headerlink" title="5XX服务器错误状态码"></a>5XX服务器错误状态码</h3><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error(内部服务器错误)</td><td>服务器遇到一个错误，使其无法为请求提供服务</td><td>状态码500</td></tr><tr><td>501</td><td>Not Implemented（未实现）</td><td>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。</td><td>状态码501</td></tr><tr><td>502</td><td>Bad Gateway（网关故障）</td><td>代理使用的服务器遇到了上游的无效响应</td><td>状态码502</td></tr><tr><td>503</td><td>Service Unavailable（未提供此服务）</td><td>服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</td><td></td></tr><tr><td>504</td><td>Gateway Timeout（网关超时）</td><td>与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</td><td></td></tr><tr><td>505</td><td>HTTP Version Not Supported（不支持的HTTP版本）</td><td>服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</td><td>状态码505</td></tr></tbody></table></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/02/HTTP状态码参考/" data-id="ckf55gcvq00142svy49ysa3fp" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/全栈/">全栈</a></li></ul></footer></div></article><article id="post-【前端开发日常-18】快速配置webpack开发环境" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/" class="article-date"><time datetime="2020-04-04T02:22:36.000Z" itemprop="datePublished">2020-04-03</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/">【前端开发日常 - 18】快速配置webpack开发环境</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line">v8.10.0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">5.6.0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> yarn -v</span></span><br><span class="line">1.13.0</span><br></pre></td></tr></table></figure><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir webpack-start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> webpack-start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm init</span></span><br></pre></td></tr></table></figure><p>根据提示输入项目信息，比如：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (webpack-start)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: 快速开始webpack开发</span><br><span class="line">entry point: (index.js) src/index.js</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords: webpack</span><br><span class="line">author: moyufed</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to F:\project\webpack-start\package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "name": "webpack-start",</span><br><span class="line">  "version": "1.0.0",</span><br><span class="line">  "description": "快速开始webpack开发",</span><br><span class="line">  "main": "src/index.js",</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "keywords": [</span><br><span class="line">    "webpack"</span><br><span class="line">  ],</span><br><span class="line">  "author": "moyufed",</span><br><span class="line">  "license": "ISC"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure><p></p><h2 id="安装-webpack-和-webpack-cli"><a href="#安装-webpack-和-webpack-cli" class="headerlink" title="安装 webpack 和 webpack-cli"></a>安装 webpack 和 webpack-cli</h2><p>现在都已经 0202 年，webpack已经是到了4的版本了，不再与webpack-cli放在同一个仓库，因此安装完 webpack 之后还需要安装 webpack-cli 搭配食用才会香。参考文章：<a href="https://stackoverflow.com/questions/49092291/the-cli-moved-into-a-separate-package-webpack-cli" target="_blank" rel="noopener">https://stackoverflow.com/questions/49092291/the-cli-moved-into-a-separate-package-webpack-cli</a></p><p class="article-more-link"><a href="/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/#more">Read More</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/" data-id="ckf55gcvz001b2svypqy8h8ma" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Webpack/">Webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-JavaScript的this关键字" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/03/31/JavaScript的this关键字/" class="article-date"><time datetime="2020-03-31T06:15:14.000Z" itemprop="datePublished">2020-03-30</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/03/31/JavaScript的this关键字/">JavaScript的this关键字</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="JavaScript的this关键字"><a href="#JavaScript的this关键字" class="headerlink" title="JavaScript的this关键字"></a>JavaScript的this关键字</h2><p><code>this</code> 关键字指向一个对象，该对象是JavaScript当前代码执行的小块。换而言之，每个JavaScript方法执行的时候都有一个执行上下文（execution context），就是我们的 this。执行上下文体现了当前方法是如何被调用的。</p><p>为了理解 <code>this</code> 关键字，我们首先要关注方法是何时、何处、以何种方式调用的，而不是关注方法在何处以何种方式声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">"Pulsar"</span>, <span class="attr">bike</span>: bike &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">"Gixxer"</span>, <span class="attr">bike</span>: bike &#125;;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Ninja"</span></span><br><span class="line">obj1.bike();      <span class="comment">// "Pulsar"</span></span><br><span class="line">obj2.bike();      <span class="comment">// "Gixxer"</span></span><br></pre></td></tr></table></figure><p>在上面的代码中， <code>bike()</code> 方法的作用就是打印 <code>this.name</code> ，也就是说打印出当前执行上下文的 <code>name</code> 属性的值。当 <code>bike()</code> 方法被调用时，打印出 “Ninja” ，因为在没有指定的情况下，执行上下文都会指向<strong>全局对象</strong>，而在全局对象上面，我们定义了一个 <code>name</code> 的属性，值是 “Ninja”。</p><p>同样的，在 <code>obj1().bike()</code> 中打印了 “Pulsar” ，因为 <code>bike()</code> 方法是以 <code>obj1</code> 作为执行上下文来调用的， <code>this.name</code> 实际上就是 <code>obj1.name</code> 。同理 <code>obj2.bike()</code> 方法的执行上下文就是 <code>obj2</code> 。</p><h2 id="This的默认绑定和隐式绑定"><a href="#This的默认绑定和隐式绑定" class="headerlink" title="This的默认绑定和隐式绑定"></a>This的默认绑定和隐式绑定</h2><p><strong>默认绑定：</strong>如果我们的代码是在严格模式（strict mode）下， <code>this</code> 的值就是 <code>undefined</code> ，否则， <code>this</code> 指代了<strong>全局对象</strong> 。</p><p>当单独使用时，它指的是<strong>全局对象</strong> ，浏览器中的<strong>全局对象</strong>其实就是 window 对象 [<strong>object Window</strong>] ，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>当在一个方法中使用，this指向全局对象，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：严格模式不允许默认绑定，所以 <code>this</code> 将会是 <code>undefined</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>隐式绑定：</strong>当使用一个对象的属性调用一个方法时，该对象就成了方法的执行上下文 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"Pulsar"</span>,</span><br><span class="line">  bike: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">"Gixxer"</span>, <span class="attr">bike</span>: obj1.bike &#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> bike = obj1.bike;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Ninja"</span></span><br><span class="line">obj1.bike();      <span class="comment">// "Pulsar"</span></span><br><span class="line">obj2.bike();      <span class="comment">// "Gixxer"</span></span><br></pre></td></tr></table></figure><p>上面的代码中，直接调用 <code>bike()</code> 就是默认绑定， <code>obj1.bike()</code> 和 <code>obj2.bike()</code> 就是隐式绑定。</p><p><code>bike</code> 方法是 <code>obj1</code> 的一个属性，但是当我们执行 <code>obj2.bike()</code> 时，执行上下文是 <code>obj2</code> ，因此<code>obj2.name</code> 的值被打印出来。</p><p>所以，清楚什么时间、什么地方、以何种方式调用方法是很重要的，而方法的声明并不影响。</p><h2 id="This的显式绑定和硬绑定"><a href="#This的显式绑定和硬绑定" class="headerlink" title="This的显式绑定和硬绑定"></a>This的显式绑定和硬绑定</h2><p><strong>显式绑定：</strong>如果我们使用 <code>call</code> 和 <code>apply</code> 来调用方法，那么方法将以第一个参数来作为它的执行上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"Pulsar"</span> &#125;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Ninja"</span></span><br><span class="line">bike.call(obj);   <span class="comment">// "Pulsar"</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们传递了一个对象 <code>obj</code> 作为 <code>call()</code> 的参数来调用 <code>bike</code> 方法，<code>obj</code> 就被指派到了 <code>this</code> ，输出<code>obj.name</code> 的值 “Pulsar” 。</p><p><strong>硬绑定：</strong>无论我们怎么调用方法，指定 <code>this</code> 对象始终不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bike = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">"Pulsar"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">"Gixxer"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> originalBikeFun = bike;</span><br><span class="line">bike = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  originalBikeFun.call(obj1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Pulsar"</span></span><br><span class="line">bike.call(obj2);  <span class="comment">// "Pulsar"</span></span><br></pre></td></tr></table></figure><p>上面的代码中使用了<code>originalBikeFun.call(obj1);</code> ，使得 <code>bike()</code> 和 <code>bike.call(obj2)</code> 都输出<code>obj1.name</code> 的值。</p><h2 id="JavaScript中的new关键字"><a href="#JavaScript中的new关键字" class="headerlink" title="JavaScript中的new关键字"></a>JavaScript中的new关键字</h2><p>任何方法之前的 <code>new</code> 关键字会调用方法的 <code>constructor</code> ，然后产生下面的结果：</p><ul><li>产生一个新的空的对象；</li><li>该新对象关联到方法的 <code>prototype</code> 属性；</li><li>该新对象被绑定为 <code>this</code> 关键字，将作为方法的执行上下文；</li><li>如果方法没有返回任何值，那将隐性的返回 this 对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line">  <span class="keyword">this</span>.maker = <span class="string">"Kawasaki"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" "</span> + maker);  <span class="comment">// undefined Bajaj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Pulsar"</span>;</span><br><span class="line"><span class="keyword">var</span> maker = <span class="string">"Bajaj"</span>;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> bike();</span><br><span class="line"><span class="built_in">console</span>.log(obj.maker);                  <span class="comment">// "Kawasaki"</span></span><br></pre></td></tr></table></figure><p>上面的代码中，<code>bike</code> 方法前面使用了 <code>new</code> ，因此它将创建一个新对象连接到 <code>bike</code> 方法的原型链, 然后该对象绑定到 <code>this</code> 从而被返回。因此返回的 <code>this</code> 对象被分配到 <code>obj</code> 然后<code>console.log(obj.maker)</code> 打印出 “Kawasaki” 。</p><p>同样是上面的代码，方法里面的 <code>this.name</code> 没有打印出 “Ninja” 或者 “Pulsar” ，反而是 <code>undefined</code> 。因为 <code>name</code> 是在方法里面被声明，和 <code>this.name</code> 是完全不同的。同样， <code>this.maker</code> 和 <code>maker</code> 也是不同的。</p><h2 id="This绑定顺序"><a href="#This绑定顺序" class="headerlink" title="This绑定顺序"></a>This绑定顺序</h2><ul><li>首先检查方法是否用 <code>new</code> 来调用;</li><li>然后检查方法是否是被 <code>call()</code> 或者 <code>apply()</code> 方法来调用;</li><li>其次检查方法是否是通过对象上下文来调用;</li><li>默认全局对象（严格模式是 <code>undefined</code> ）。</li></ul><p>原文链接：<a href="https://codeburst.io/all-about-this-and-new-keywords-in-javascript-38039f71780c" target="_blank" rel="noopener">https://codeburst.io/all-about-this-and-new-keywords-in-javascript-38039f71780c</a></p><p>参考链接：<a href="https://segmentfault.com/a/1190000004460913" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004460913</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/03/31/JavaScript的this关键字/" data-id="ckf55gcts00032svy6qa6118q" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/03/31/File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）/" class="article-date"><time datetime="2020-03-31T06:13:32.000Z" itemprop="datePublished">2020-03-30</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/03/31/File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）/">File APIs（Blob, BlobURL, ArrayBuffer, FileReader）</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前的JavaScript很不擅长处理二进制数据，要将二进制数据保存在浏览器上使用需要牺牲1.3倍的存储空间（将数据转换成 <code>DataURI</code> ）。即使是使用 <code>XHR</code> 从服务器请求数据，将读入内存之后还需要转换成 <code>Base64</code> / <code>DataURI</code> ），过程十分繁琐。</p><p>但是，时代已经变了。</p><p>现在的JavaScript中，处理二进制数据已经不是难题。硬件和 JIT（just-in-time）编译器的升级，让H5实现大多数API来处理大容量的二进制数据。</p><p>下面来介绍HTML5的Blob, File, FileList等对象，以及它们之间的相互转换。</p><h2 id="HTML5的File-API和对象"><a href="#HTML5的File-API和对象" class="headerlink" title="HTML5的File API和对象"></a>HTML5的File API和对象</h2><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p>Blob可以更好的处理二进制数据和文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">    readonly size: UINT64 = <span class="number">0</span>,</span><br><span class="line">    readonly type: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(source:AnyArray, option:BlobTypeObject = null):Blob &#123; &#125;,</span><br><span class="line">    slice(start:INT64 = <span class="number">0</span>, <span class="attr">end</span>:INT64 = <span class="number">0</span>, <span class="attr">contentType</span>:<span class="built_in">String</span> = <span class="string">""</span>):Blob &#123; &#125;,</span><br><span class="line">    close():<span class="keyword">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobTypeObject</span> </span>&#123;</span><br><span class="line">    readonly type: <span class="built_in">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Blob具有 <code>size</code> 和 <code>type</code> 属性，并且还有 <code>slice</code> 和 <code>close</code> 方法，可以在 <code>ArrayBuffer</code> 或 <code>BlobURL</code> 之间相互转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([ <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> ]);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([ source ]);</span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(reader.result); <span class="comment">// reader.result 是 ArrayBuffer</span></span><br><span class="line">&#125;;</span><br><span class="line">reader.readAsArrayBuffer(blob);</span><br></pre></td></tr></table></figure><p>Blob构造器的第一参数指定一个数组，这个数组的元素类型可以是 <code>Blob</code> 、<code>ArrayBuffer</code> 、<code>TypedArray</code>、<code>String</code> 或 <code>Object</code> 。如果是 <code>Object</code> 的情况还需要用 <code>toString</code> 方法转换成字符串。如果有多个项的情况，将按照顺序链接Blob对象内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的Blob对象</span></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob();</span><br></pre></td></tr></table></figure><p>Blob的第二个参数指定了 <code>{ type: MimeTypeString }</code> ，<code>MimeTypeString</code> 设置了Blob的种类 <code>MimeType</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 octet-binary Blob 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer1 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> buffer2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([buffer1, buffer2], &#123; <span class="attr">type</span>: <span class="string">"application/octet-binary"</span> &#125;);</span><br></pre></td></tr></table></figure><p>通常使用二进制数据时会指定类型，如： <code>{ type: &quot;application/octet-binary&quot; }</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([file], &#123; <span class="attr">type</span>: <span class="string">"image/png"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([binary], &#123; <span class="attr">type</span>: <span class="string">"application/octet-binary"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">"字符串"</span>], &#123; <span class="attr">type</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">"&lt;html&gt;"</span>], &#123; <span class="attr">type</span>: <span class="string">"text/plain;charset=UTF-8"</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File继承了Blob对象。并且追加了Blob的 <code>{ name:String, lastModifiedDate:Date }</code> 属性，File 是 JavaScript 中少数处理本地文件方法的一种。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">    readonly name: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line">    readonly lastModifiedDate: <span class="built_in">Date</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly webkitRelativePath: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(source:Blob, fileName:String):File &#123; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Chrome中，File的构造器需要指定一个数组： <code>new File([], ...)</code> ，扩展了 <code>{ lastModified: Integer, webkitRelativePath: String }</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chrome的示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">    readonly name: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line">    readonly lastModified: Integer = <span class="number">0</span>,</span><br><span class="line">    readonly lastModifiedDate: <span class="built_in">Date</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly webkitRelativePath: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(source:AnyArray, fileName:String):File &#123; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于File继承了Blob，因此File也支持使用 <code>FileReader.readAsArrayBuffer()</code> API转换为Blob。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">reader.readAsArrayBuffer(file);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_toBlob</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.responseType = <span class="string">"blob"</span>;</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(xhr.response, url);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_toBlob(location.href, <span class="function"><span class="keyword">function</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> blobURL = URL.createObjectURL(blob);</span><br><span class="line">    <span class="keyword">var</span> file = <span class="keyword">new</span> File([blob], <span class="string">"foo.html"</span>); <span class="comment">// 或者是 new File(blob, ...)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="FileList"><a href="#FileList" class="headerlink" title="FileList"></a>FileList</h3><p><code>FileList</code> 是通过DOM如 <code>&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot;&gt;</code> 的 <code>onchange</code> 取得的File的列表。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[type="file"]'</span>).addEventListener(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileList = event.target.files; <span class="comment">// ArrayLikeObject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, iz = fileList.length; i &lt; iz; ++i) &#123;</span><br><span class="line">        <span class="keyword">var</span> file = fileList[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    readonly length: UINT32 = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    item(index:UINT32):File &#123; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><code>FileReader</code> 类可以将二进制数据读入内存。</p><p>使用 <code>readAsArrayBuffer</code> 方法可以将 <code>Blob</code> 转换成 <code>ArrayBuffer</code> ，转换的结果通过 <code>result</code> 属性进行设置，同样可以使用 <code>readAsDataURL</code> 或 <code>readAsText</code> 等方法进行转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line">    EMPTY:   UINT16 = <span class="number">0</span>,</span><br><span class="line">    LOADING: UINT16 = <span class="number">1</span>,</span><br><span class="line">    DONE:    UINT16 = <span class="number">2</span>,</span><br><span class="line">    readonly error: <span class="built_in">Error</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly result: <span class="built_in">ArrayBuffer</span>|<span class="built_in">String</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly readyState: UINT16 = EMPTY,</span><br><span class="line">    onload:      EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onloadstart: EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onloadend:   EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onprogress:  EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onabort:     EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onerror:     EventHandler = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async read methods</span></span><br><span class="line">    readAsArrayBuffer(blob:Blob): <span class="keyword">void</span> &#123;&#125;,</span><br><span class="line">    readAsDataURL(blob:Blob):<span class="keyword">void</span> &#123;&#125;,</span><br><span class="line">    readAsText(blob:Blob, <span class="attr">label</span>:<span class="built_in">String</span> = <span class="string">""</span>):<span class="keyword">void</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    abort():<span class="keyword">void</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chrome中还有 <code>readAsBinaryString(blob:Blob):void {}</code> 方法。</p><h3 id="BlobURL生成和释放"><a href="#BlobURL生成和释放" class="headerlink" title="BlobURL生成和释放"></a>BlobURL生成和释放</h3><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p><code>BlobURL</code> 是 <code>blob:...</code> 的形式的假象URL，可以通过 <code>URL.createObjectURL(source:Blob):BlobURLString</code> 来动态生成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uint8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([uint8Array], &#123; <span class="attr">type</span>: <span class="string">"application/octet-binary"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blobURL = URL.createObjectURL(blob); <span class="comment">// "blob:http%3A//dev.w3.org/207c851d-7486-42ec-97b1-d3cd26d08ed9"</span></span><br></pre></td></tr></table></figure><p><code>URL.createObjectURL</code> 总是生成唯一的 <code>BlobURL</code> （对于同一个资源每次都会生成不同的URL），生成的 <code>BlobURL</code> 在浏览器关闭之前有效。</p><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>如果要释放BlobURL，可以调用 <code>URL.revokeObjectURL(blobURL:BlobURLString):void</code> 方法。当然，也有 <code>URL.createFor(Blob):BlobURLString</code> 创建可以自动释放的BlobURL，不过要考虑兼容性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blobURL = URL.createObjectURL(file);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">URL.revokeObjectURL(blobURL);</span><br></pre></td></tr></table></figure><p><code>img.src</code> 、 <code>XMLHttpRequest.open(method, URL)</code> 、<code>Audio</code> 等需要使用 URL 请求文件的情况，也可以通过生成BlobURL发送。</p><p>与DataURI时相比，使用BlobURL在速度和内存占用方面都更有优势，尤其是处理Audio等流式传输数据时，其差异会更明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">img.src = blobURL;</span><br></pre></td></tr></table></figure><p>Chrome可以通过访问chrome://blob-internals/来确认有效的BlobURL。</p><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><h3 id="Blob-File-BlobURL的相互转换"><a href="#Blob-File-BlobURL的相互转换" class="headerlink" title="Blob, File, BlobURL的相互转换"></a>Blob, File, BlobURL的相互转换</h3><p>BlobURL可以通过XMLHttpRequest转换成Blob或者ArrayBuffer等其它类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = xhr.response; <span class="comment">// ArrayBuffer</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.responseType = <span class="string">"arraybuffer"</span>;</span><br><span class="line"><span class="comment">//xhr.responseType = "blob";</span></span><br><span class="line">xhr.open(<span class="string">"GET"</span>, blobURL);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>Blob,，BlobURLString， ArrayBuffer的相互转换可以通过以下方法：</p><table><thead><tr><th style="text-align:left">原始</th><th style="text-align:left">目标</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">BlobURLString</td><td style="text-align:left">URL.createObjectURL(…)</td></tr><tr><td style="text-align:left">BlobURL</td><td style="text-align:left">Blob</td><td style="text-align:left">XMLHttpRequest#responseType = “blob”</td></tr><tr><td style="text-align:left">BlobURL</td><td style="text-align:left">ArrayBuffer</td><td style="text-align:left">XMLHttpRequest#responseType = “arraybuffer”</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">ArrayBuffer</td><td style="text-align:left">FileReader#readAsArrayBuffer(…)</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">BinaryString</td><td style="text-align:left">FileReader#readAsBinaryString(…)</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">DataURLString</td><td style="text-align:left">FileReader#readAsDataURL(…)</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">String</td><td style="text-align:left">FileReader#readAsText(…, 编码方式)</td></tr></tbody></table><p>转换ArryBuffer的方式可以如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_toArrayBuffer</span>(<span class="params">source,     <span class="regexp">//</span> @arg BlobURLString|URLString|Blob|File|TypedArray|ArrayBuffer</span></span></span><br><span class="line"><span class="function"><span class="params">                        callback</span>) </span>&#123; <span class="comment">// @arg Function - callback(result:ArrayBuffer, source:Any):void</span></span><br><span class="line">    <span class="keyword">if</span> (source.buffer) &#123;</span><br><span class="line">        <span class="comment">// TypedArray</span></span><br><span class="line">        callback(source.buffer, source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>) &#123;</span><br><span class="line">        <span class="comment">// ArrayBuffer</span></span><br><span class="line">        callback(source, source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Blob) &#123;</span><br><span class="line">        <span class="comment">// Blob or File</span></span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(reader.result, source);</span><br><span class="line">        &#125;;</span><br><span class="line">        reader.readAsArrayBuffer(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="comment">// BlobURLString or URLString</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.responseType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(xhr.response, source);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.open(<span class="string">"GET"</span>, source);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Unknown type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileReader#readAsText(blob, &quot;UTF-8&quot;)</code> 第二个参数可以指定编码方式，默认为 “UTF-8” ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = reader.result; <span class="comment">// String</span></span><br><span class="line">&#125;;</span><br><span class="line">reader.readAsText(file, <span class="string">"UTF-16"</span>);</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>《File APIs(Blob, BlobURL, ArrayBuffer, FileReader)》：<a href="https://qiita.com/TypoScript/items/0d5b08cecf959b8b822c" target="_blank" rel="noopener">https://qiita.com/TypoScript/items/0d5b08cecf959b8b822c</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/03/31/File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）/" data-id="ckf55gcvi00132svyxewk36un" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-使用Taro开发一个微信小程序一" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2019/12/17/使用Taro开发一个微信小程序一/" class="article-date"><time datetime="2019-12-17T05:02:46.000Z" itemprop="datePublished">2019-12-16</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2019/12/17/使用Taro开发一个微信小程序一/">使用Taro开发一个微信小程序一</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="使用Taro开发一个微信小程序（一），小程序注册、项目创建"><a href="#使用Taro开发一个微信小程序（一），小程序注册、项目创建" class="headerlink" title="使用Taro开发一个微信小程序（一），小程序注册、项目创建"></a>使用Taro开发一个微信小程序（一），小程序注册、项目创建</h1><p>视频地址：<a href="https://www.bilibili.com/video/av76872374/" target="_blank" rel="noopener">https://www.bilibili.com/video/av76872374/</a></p><h3 id="为什么使用Taro"><a href="#为什么使用Taro" class="headerlink" title="为什么使用Taro"></a>为什么使用Taro</h3><ul><li>Taro是一个支持多端开发的框架，写一套代码可以编译成各主流小程序，并且包括H5和RN。</li><li>和React接轨，方便在React和Taro之间无缝切换，学习门槛不会太高。</li></ul><p>关于Taro技术选型，这里有一篇介绍，<a href="http://blog.moyufed.com/2019/11/23/Taro%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B8%8E%E6%9D%83%E8%A1%A1/">去查看</a> 。</p><h3 id="注册小程序"><a href="#注册小程序" class="headerlink" title="注册小程序"></a>注册小程序</h3><ol><li>注册小程序需要一个电子邮箱，然后进入<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a>，点击 【立即注册】。</li><li>进入到账号类型选择，点击【小程序】，注意，<strong>一个邮箱只能注册一个账号类型，这些账号可以关联到同一个微信号</strong> 。</li><li>完善注册信息，需要输入邮箱地址、密码并且确认密码，填入验证码之后点击【注册】。</li><li>注册之后，会提示验证邮箱，点击【登录邮箱】去到收件箱找到微信发送的邮件，点击详情里面的链接完成验证。</li><li>完善微信小程序主体信息，包括账号地区、主体类型（个人）、以及主体的信息，然后使用微信二维码扫描验证。</li><li>提交信息完成之后，即可点击【前往小程序】跳转到小程序管理页面，到这步，我们已经完成了小程序的注册。</li></ol><h3 id="下载安装微信开发工具"><a href="#下载安装微信开发工具" class="headerlink" title="下载安装微信开发工具"></a>下载安装微信开发工具</h3><p>在进行微信小程序开发的过程中，我们需要使用到微信开发工具，<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">点击进入</a>，我们可以选择自己喜欢的版本进行下载，下载完成之后双击执行安装，不多做介绍。</p><h3 id="下载Taro"><a href="#下载Taro" class="headerlink" title="下载Taro"></a>下载Taro</h3><p>详细详情，可以参考<a href="https://taro-docs.jd.com/taro/docs/GETTING-STARTED.html" target="_blank" rel="noopener">Taro文档</a> ，下面做要点介绍：</p><p>首先检查 <code>nodejs</code> 版本，打开命令行工具（本人使用 ConEmu ），在命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v8.<span class="number">10.0</span></span><br></pre></td></tr></table></figure><blockquote><p>Taro 项目基于 node，请确保已具备较新的 node 环境（&gt;=8.0.0），推荐使用 node 版本管理工具 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a> 来管理 node，这样不仅可以很方便地切换 node 版本，而且全局安装时候也不用加 sudo 了。</p></blockquote><p>关于 nvm 安装，这里有一个介绍视频，<a href="https://www.bilibili.com/video/av71367431/" target="_blank" rel="noopener">点击查看</a> 。接着执行命令安装Taro：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g @tarojs/cli</span><br></pre></td></tr></table></figure><p>为了避免我们在使用 <code>sass</code> 时出现安装安装错误，可以再全局安装<a href="https://www.npmjs.com/package/mirror-config-china" target="_blank" rel="noopener"><code>mirror-config-china</code></a>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g mirror-config-china</span><br></pre></td></tr></table></figure><p>安装完成之后，可以执行命令查看Taro的信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ taro info</span><br><span class="line">👽 Taro v1.<span class="number">3.25</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Taro CLI <span class="number">1.3</span>.<span class="number">25</span> environment info:</span><br><span class="line">    System:</span><br><span class="line">      OS: Windows <span class="number">10</span></span><br><span class="line">    Binaries:</span><br><span class="line">      Node: <span class="number">8.10</span>.<span class="number">0</span> - C:\Program Files\nodejs\node.EXE</span><br><span class="line">      Yarn: <span class="number">1.19</span>.<span class="number">1</span> - C:\Program Files (x86)\Yarn\bin\yarn.CMD</span><br><span class="line">      npm: <span class="number">5.6</span>.<span class="number">0</span> - C:\Program Files\nodejs\npm.CMD</span><br></pre></td></tr></table></figure><h3 id="创建第一个-Taro-项目"><a href="#创建第一个-Taro-项目" class="headerlink" title="创建第一个 Taro 项目"></a>创建第一个 Taro 项目</h3><p>执行命令创建项目：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ taro init 项目名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以本次实战项目为例</span></span><br><span class="line">$ taro init moyufed</span><br><span class="line">√ 拉取远程模板仓库成功！</span><br><span class="line">? 请输入项目名称！ moyufed</span><br><span class="line">? 请输入项目介绍！ 项目介绍</span><br><span class="line">? 是否需要使用 TypeScript ？ No</span><br><span class="line">? 请选择 CSS 预处理器（Sass/Less/Stylus） Sass</span><br><span class="line">? 请选择模板 mobx</span><br></pre></td></tr></table></figure><p>执行 <code>init</code> 之后，Taro 会自动执行依赖的安装。如果执行安装失败，我们可以按 ctrl+c 结束，手动执行命令安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yarn 安装依赖</span></span><br><span class="line">$ yarn install</span><br><span class="line"><span class="comment"># 或者使用 npm 安装依赖</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>执行命令启动：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yarn</span></span><br><span class="line">$ yarn dev:weapp</span><br><span class="line">$ yarn build:weapp</span><br><span class="line"><span class="comment"># 使用 npm script</span></span><br><span class="line">$ npm run dev:weapp</span><br><span class="line">$ npm run build:weapp</span><br></pre></td></tr></table></figure><h3 id="运行和预览"><a href="#运行和预览" class="headerlink" title="运行和预览"></a>运行和预览</h3><p>打开已经下载安装好的微信开发工具，用自己的微信扫描登录。然后进入项目目录，执行命令启动dev ：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yarn</span></span><br><span class="line">$ yarn dev:weapp</span><br><span class="line"><span class="comment"># 使用 npm script</span></span><br><span class="line">$ npm run dev:weapp</span><br></pre></td></tr></table></figure><p>为了能够使用刚注册好的小程序进行预览，先去完善小程序信息：</p><ol><li>进入微信公众平台小程序首页，点击小程序信息栏目的【填写】前往信息完善页面，完善和提交小程序信息之后，点击右侧【开发】菜单，选择【开发设置】标签，可以看到小程序ID，复制小程序ID，填入项目根目录的 <code>project.config.json</code> ，修改<code>appid</code> 的值为小程序的ID。</li><li>在小程序开发工具中，点击新建小程序，选择【导入项目】，下拉选择我们创建的小程序项目根文件夹，点击【导入】，这时我们就可以边修改代码边查看小程序效果了。</li></ol><p>更多详情，可以点击文章开头的视频连接查看。</p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2019/12/17/使用Taro开发一个微信小程序一/" data-id="ckf55gcuf000c2svyrbiqiika" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/">Nodejs</a></li></ul></footer></div></article><article id="post-个人账单和砸金蛋前端动画分享" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2019/11/24/个人账单和砸金蛋前端动画分享/" class="article-date"><time datetime="2019-11-24T07:31:33.000Z" itemprop="datePublished">2019-11-23</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2019/11/24/个人账单和砸金蛋前端动画分享/">个人账单和砸金蛋前端动画分享</a></h1></header><div class="article-entry" itemprop="articleBody"><p>我们在前端开发过程中，有时候实现一些页面效果需要用到CSS3动画，比如活动页面、抽奖页面、个人账单等。我们可以照着设计师给的效果实现，但是我们追求的不止是这样，我们需要实现精致的动画，流畅的体验，还有新颖的交互。下面分享我在做个人账单、砸蛋抽奖过程中的心得。</p><h4 id="开发之前需要和产品与设计进行相关内容的确认"><a href="#开发之前需要和产品与设计进行相关内容的确认" class="headerlink" title="开发之前需要和产品与设计进行相关内容的确认"></a>开发之前需要和产品与设计进行相关内容的确认</h4><p>为了提高效率、减少开发难度、避免重复劳动，我们需要提前做好准备：</p><ul><li>产品和设计并提出的需求也许和实现冲突，作为开发人员需要与其确认可行的方案。</li></ul><ul><li>向设计确认设计规范、适配等，或者提出自己认为更好的效果，按照规范进行设计有利于效果和动画实现。</li><li>确认效果图是否符合规范，设计师切图是否有明确的标注，图片是否压缩。</li></ul><h4 id="Transitions-Transforms和Animation简介"><a href="#Transitions-Transforms和Animation简介" class="headerlink" title="Transitions, Transforms和Animation简介"></a>Transitions, Transforms和Animation简介</h4><p>CSS3动画相关的几个属性是：<code>transition</code>, <code>transform</code>, <code>animation</code> ，分别可以理解为过渡属性，变换属性，动画属性。</p><h5 id="Transiton"><a href="#Transiton" class="headerlink" title="Transiton"></a>Transiton</h5><p><code>transiton</code> 属性是一个简写属性，用于设置四个过渡属性：</p><ul><li><p><code>transition-property</code> 指定过渡的CSS属性值，比如 <code>transition-property:opacity</code> 就是只指定 <code>opacity</code> 属性参与这个过渡， 还可以使用 <code>all</code> 指定所有的属性值。</p></li><li><p><code>transition-duration</code> 指定过渡的持续时间</p></li><li><p><code>transition-delay</code> 延迟过渡时间</p></li><li><p><code>transition-timing-function</code> 指定过渡动画缓动类型，有<code>ease</code> | <code>linear</code> | <code>ease-in</code> | <code>ease-out</code> | <code>ease-in-out</code> | <code>cubic-bezier()</code>其中，<code>linear</code>线性过度，<code>ease-in</code>由慢到快，<code>ease-out</code>由快到慢，<code>ease-in-out</code>由慢到快在到慢。<br>我们通常使用简写 <em>transition: property duration timing-function delay;</em> ， 如：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.global-wrap</span> <span class="selector-class">.bg</span> &#123;<span class="attribute">transition</span>: all <span class="number">1s</span> .<span class="number">6s</span> ease-out;&#125;</span><br></pre></td></tr></table></figure><p class="article-more-link"><a href="/2019/11/24/个人账单和砸金蛋前端动画分享/#more">Read More</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2019/11/24/个人账单和砸金蛋前端动画分享/" data-id="ckf55gcwi001l2svytj1ij58m" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/">Nodejs</a></li></ul></footer></div></article><article id="post-Taro技术选型与权衡" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2019/11/24/Taro技术选型与权衡/" class="article-date"><time datetime="2019-11-24T07:03:38.000Z" itemprop="datePublished">2019-11-23</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2019/11/24/Taro技术选型与权衡/">Taro技术选型与权衡</a></h1></header><div class="article-entry" itemprop="articleBody"><p>Taro 是由凹凸实验室打造的一套遵循 React 语法规范的多端统一开发框架。</p><p>今市面上应用的形态多种多样，Web、Native、微信小程序等，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码。</p><h3 id="Taro-有哪些特性"><a href="#Taro-有哪些特性" class="headerlink" title="Taro 有哪些特性"></a>Taro 有哪些特性</h3><ul><li><p>一键生成可以在微信小程序/H5/ReactNative等端运行的代码</p></li><li><p>采用React语法标准，支持JSX书写，现代的编辑器默认都对 JSX 进行了支持</p></li><li><p>支持组件化开发，让代码可以复用，让功能开发更加清晰</p></li><li>全面支持TypeScript</li><li>代码提示，实时代码检查，提升 开发效率</li><li>配套的开发工具Taro CLI实现开发流程自动化</li></ul><h3 id="Taro支持的平台"><a href="#Taro支持的平台" class="headerlink" title="Taro支持的平台"></a>Taro支持的平台</h3><ul><li>微信小程序</li><li>H5</li><li>React Native</li><li>支付宝小程序</li><li>百度智能小程序</li><li>字节跳动小程序</li><li>快应用（未上线）</li><li>QQ 浏览器轻应用 （未上线）</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>Taro 全都是 <code>Component</code> 组件，并且和 React 的生命周期完全一致。掌握了 React 就几乎掌握了 Taro。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View, Button &#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      title: <span class="string">'首页'</span>,</span><br><span class="line">      list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillMount () &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount () &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  componentWillUpdate (nextProps, nextState) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate (prevProps, prevState) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  shouldComponentUpdate (nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dosth</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'index'</span>&gt;</span><br><span class="line">        &lt;View className=<span class="string">'title'</span>&gt;&#123;<span class="keyword">this</span>.state.title&#125;&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &lt;View className='content'&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.list.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return (</span></span><br><span class="line"><span class="regexp">              &lt;View className='item'&gt;&#123;item&#125;&lt;/</span>View&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">          &lt;Button className=<span class="string">'add'</span> onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;添加&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>View&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="技术选型与权衡"><a href="#技术选型与权衡" class="headerlink" title="技术选型与权衡"></a>技术选型与权衡</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>一键生成可以在微信小程序/H5/ReactNative等端运行的代码，小程序端已支持微信小程序、支付宝小程序，但无法提供在线版，H5 端、RN 端可在线预览。</li><li>使用 <code>TypeScript</code> 来对代码的可靠性进一步增强，或使用 <code>PropsType</code> 在运行时进一步保障代码可靠性。</li><li>Taro 的所有 API（包括微信小程序等端能力接口）都有智能的提醒和自动补全，包括接口的参数和返回值。</li><li>Taro语法规范遵循React规范，熟悉React就能使用Taro进行开发。</li><li>使用JSX作为模板和业务代码系统，JSX 的本质就是 JavaScript 的语法增强，所以例如没有 <code>import</code> 组件等语法错误在编译期就能发现。</li><li>支持sass、less、postcss。</li><li>支持React 组件化规范，组件可复用多端。</li><li>内建构建系统+webpack自动构建</li><li>全面支持TypeScript</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="React-like不完全等同-React"><a href="#React-like不完全等同-React" class="headerlink" title="React-like不完全等同 React"></a>React-like不完全等同 React</h5><ul><li>小程序中受限于 WXML 语法 ，组件调用不支持扩展操作符</li><li>JSX暂时只能写在render中</li></ul><h5 id="多端差异不可避免"><a href="#多端差异不可避免" class="headerlink" title="多端差异不可避免"></a>多端差异不可避免</h5><ul><li>某些功能在相应端上没有支持</li><li>样式支持、写法上存在差异</li></ul><h5 id="没有真正支持多端的UI组件库"><a href="#没有真正支持多端的UI组件库" class="headerlink" title="没有真正支持多端的UI组件库"></a>没有真正支持多端的UI组件库</h5><ul><li>Taro UI 是基于 Taro 框架开发的多端 UI 组件</li><li>Taro UI 暂不支持 React Native</li></ul><h4 id="存在的坑"><a href="#存在的坑" class="headerlink" title="存在的坑"></a>存在的坑</h4><h5 id="样式差异管理"><a href="#样式差异管理" class="headerlink" title="样式差异管理"></a>样式差异管理</h5><ul><li>因为 React Native 与一般 Web 样式支持度差异较大，用了大量 RN 不支持的样式再要去兼容 RN 无异于重写页面。</li><li>样式上 H5 最为灵活，小程序次之，RN 最弱，统一多端样式即是对齐短板，也就是要以 RN 的约束来管理样式，同时兼顾小程序的限制。</li></ul><h5 id="H5-端的坑"><a href="#H5-端的坑" class="headerlink" title="H5 端的坑"></a>H5 端的坑</h5><ul><li>Taro 对H5 端的支持度尚可，在 CSS 特性上就不用像 RN 那样拘束。</li><li>内置组件不够完善、端能力缺失较多，Taro 的设计是以微信小程序为基准。</li><li>小程序、RN 都没有跨域问题，但 H5 会有，这个可通过 devServer.proxy 解决</li><li>以及编译打包的静态资源是固定文件名，改成带 hash 值方便缓存管理，这些配置在项目里的 src/config 。</li></ul><h5 id="对React-Native-支持可能存在部分问题"><a href="#对React-Native-支持可能存在部分问题" class="headerlink" title="对React Native 支持可能存在部分问题"></a>对React Native 支持可能存在部分问题</h5><ul><li>React Native 不支持 text-overflow，而是提供原生支持 （Text 组件传入 numberOfLines={num} 属性）</li><li>React Native 的 view 不支持 click 事件，需要用 Touchable 组件</li></ul><h5 id="多端要求较高"><a href="#多端要求较高" class="headerlink" title="多端要求较高"></a>多端要求较高</h5><ul><li>对不同端的具体差异有所了解</li><li>样式实现较为苛刻，需兼顾多端、有所取舍</li><li>端能力差异可能需要自己填坑</li><li>需要对隔断差异做出取舍</li></ul><h5 id="新手使用"><a href="#新手使用" class="headerlink" title="新手使用"></a>新手使用</h5><ul><li>需要上手React、了解Redux数据流管理</li><li>和现有 ionic 组件会有出入的地方需要兼顾和取舍</li></ul><h3 id="多端填坑方式"><a href="#多端填坑方式" class="headerlink" title="多端填坑方式"></a>多端填坑方式</h3><ul><li>Taro 支持环境判断编译时只保留相应端代码</li><li>Taro 支持引入相应端的原生代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">    <span class="comment">// 微信小程序逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">    <span class="comment">// H5 逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'rn'</span>) &#123;</span><br><span class="line">    <span class="comment">// RN 逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术和开发"><a href="#技术和开发" class="headerlink" title="技术和开发"></a>技术和开发</h3><ul><li>学习 React/Redux</li><li>采用自有UI组件和Taro UI，减少多端成本。</li><li>适配着重于兼容RN，小程序，根据多端差异协调取舍。</li><li>以H5为主、小程序为辅、RN次之的适配方案，能够快速应对项目二开，从了解到熟悉，循序渐进。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Taro 虽然是以多端为设计目标，但重心是小程序端，RN 端目前的支持情况不算特别理想。但充分理解多端差异、掌握正确的多端开发的方式，在简单的项目上是完全值得尝试。</p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2019/11/24/Taro技术选型与权衡/" data-id="ckf55gctx00042svyune86k6k" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-Windows下安装NVM" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2019/11/24/Windows下安装NVM/" class="article-date"><time datetime="2019-11-24T06:30:15.000Z" itemprop="datePublished">2019-11-23</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2019/11/24/Windows下安装NVM/">Windows下安装NVM</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="Windows下安装NVM"><a href="#Windows下安装NVM" class="headerlink" title="Windows下安装NVM"></a>Windows下安装NVM</h1><p>视频地址：<a href="https://www.bilibili.com/video/av71367431/" target="_blank" rel="noopener">https://www.bilibili.com/video/av71367431/</a></p><h3 id="1、事先准备"><a href="#1、事先准备" class="headerlink" title="1、事先准备"></a>1、事先准备</h3><p>卸载已有的 <code>nodejs</code> ，并移除原有的 <code>nodejs</code> 目录（重要）</p><h3 id="2、下载和安装nvm"><a href="#2、下载和安装nvm" class="headerlink" title="2、下载和安装nvm"></a>2、下载和安装nvm</h3><p>访问 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">下载地址</a> 选择自己需要的nvm版本进行下载，下载 <a href="https://github.com/coreybutler/nvm-windows/releases/download/1.1.7/nvm-setup.zip" target="_blank" rel="noopener">nvm-setup.zip</a> ，解压并执行里面的 <code>.exe</code> 文件进行安装</p><h3 id="3、修改为淘宝镜像"><a href="#3、修改为淘宝镜像" class="headerlink" title="3、修改为淘宝镜像"></a>3、修改为淘宝镜像</h3><p>以本机为例，修改 <code>C:\Users\Administrator\AppData\Roaming\nvm\settings.txt</code> 文件增加淘宝下载镜像地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root: C:\Users\Administrator\AppData\Roaming\nvm</span><br><span class="line">path: C:\Program Files\nodejs</span><br><span class="line">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure><h3 id="4、打开CMD，执行nvm查看是否安装成功"><a href="#4、打开CMD，执行nvm查看是否安装成功" class="headerlink" title="4、打开CMD，执行nvm查看是否安装成功"></a>4、打开CMD，执行nvm查看是否安装成功</h3><p>1.nvm 安装，直接下载github 安装包即可。</p><p>2.nvm 安装成功后，需要手动的开启。</p><p>nvm on</p><p>3.不进行第二步，nvm install 8.9.0 ，输入node，依旧提示</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'node'</span> is not recognized as an internal or external command,</span><br><span class="line">operable program or batch file.</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5cfde431e51d45775b419bac" target="_blank" rel="noopener">Win10 nvm 安装node 之 nvm on</a><br><a href="https://stackoverflow.com/questions/28313372/nvm-for-windows-not-working" target="_blank" rel="noopener">NVM for Windows not working?</a><br><a href="https://github.com/coreybutler/nvm-windows/issues/216" target="_blank" rel="noopener"><code>nvm node_mirror [url]</code> not work</a><br><a href="https://www.jianshu.com/p/d0e0935b150a" target="_blank" rel="noopener">nvm介绍及使用</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2019/11/24/Windows下安装NVM/" data-id="ckf55gcu000052svy1s9fb7qv" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/">Nodejs</a></li></ul></footer></div></article><nav id="page-nav"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a></nav></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongodb/">Mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全栈/">全栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/Linux/" style="font-size:10px">Linux</a> <a href="/tags/Mongodb/" style="font-size:10px">Mongodb</a> <a href="/tags/Nodejs/" style="font-size:16.67px">Nodejs</a> <a href="/tags/React/" style="font-size:16.67px">React</a> <a href="/tags/Webpack/" style="font-size:10px">Webpack</a> <a href="/tags/全栈/" style="font-size:13.33px">全栈</a> <a href="/tags/前端/" style="font-size:20px">前端</a></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul><li><a href="/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/">【前端开发日常 - 3】让create-react-app支持@装饰器语法</a></li><li><a href="/2020/09/14/通过rel-preload进行内容预加载/">通过rel=preload进行内容预加载</a></li><li><a href="/2020/09/02/HTTP状态码参考/">HTTP状态码参考</a></li><li><a href="/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/">【前端开发日常 - 18】快速配置webpack开发环境</a></li><li><a href="/2020/03/31/JavaScript的this关键字/">JavaScript的this关键字</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2020 摸鱼前端 | Moyufed<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><br><a href="http://www.beian.miit.gov.cn" target="_blank">黔ICP备18007258号</a></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives" class="mobile-nav-link">Archives</a></nav><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body>