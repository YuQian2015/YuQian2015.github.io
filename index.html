<!DOCTYPE html><html><head><meta charset="utf-8"><title>摸鱼前端 | Moyufed</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu-site-verification" content="bWMteHRHG2"><meta name="description" content="分享有趣好玩的前端技术"><meta name="keywords" content="前端,全栈,分享,nodejs,webpack,linux"><meta property="og:type" content="website"><meta property="og:title" content="摸鱼前端 | Moyufed"><meta property="og:url" content="http://blog.moyufed.com/index.html"><meta property="og:site_name" content="摸鱼前端 | Moyufed"><meta property="og:description" content="分享有趣好玩的前端技术"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="摸鱼前端 | Moyufed"><meta name="twitter:description" content="分享有趣好玩的前端技术"><link rel="alternate" href="/atom.xml" title="摸鱼前端 | Moyufed" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">摸鱼前端 | Moyufed</a></h1><h2 id="subtitle-wrap"><a href="/" id="subtitle">分享有趣好玩的前端技术，游戏研究猿，欢迎交流，一起来摸鱼。</a></h2></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives">Archives</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="搜索"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.moyufed.com"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-【前端开发日常-4】Windows安装Redis及简单使用" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/10/01/【前端开发日常-4】Windows安装Redis及简单使用/" class="article-date"><time datetime="2020-10-01T01:08:15.000Z" itemprop="datePublished">2020-09-30</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/10/01/【前端开发日常-4】Windows安装Redis及简单使用/">【前端开发日常 - 4】Windows安装Redis及简单使用</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>目前在使用阿里 Egg.js 开发后台应用，考虑到一些高并发的接口会经常调用数据库查询，因此增加Redis作为服务端缓存。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>安装 Redis，由于系统是 Windows7，因此需要下载对应 Windows 的版本，下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a></p></li><li><p>简单配置 Redis 启动，为 Redis 的连接增加密码，以确保安全性</p></li></ol><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><p>访问上面的【下载地址】，选择需要的版本，展开 Assets 目录，可以选择 .msi 文件或 .zip 文件下载。如果下载 <strong>.msi</strong> 文件，可以直接执行安装（勾选对应的复选框），安装通过之后，Windows 会直接将 Redis 写入服务。</p><p>如果下载 <strong>.zip</strong> 文件，还需要对文件进行解压和安装，需要在 redis 目录执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe --service-install redis.windows.conf</span></span><br></pre></td></tr></table></figure><p>上面的命令会安装一个Windows服务，关于服务的命令有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe --service-uninstall <span class="comment"># 卸载服务</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe --service-start <span class="comment"># 开启服务</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe --service-stop <span class="comment"># 停止服务</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe --service-name name <span class="comment"># 重命名服务</span></span></span><br></pre></td></tr></table></figure><h3 id="检查-Windows-服务"><a href="#检查-Windows-服务" class="headerlink" title="检查 Windows 服务"></a>检查 Windows 服务</h3><p>以 Windows7 为例，可以进入 控制面板\所有控制面板项\管理工具 找到 【服务】，点开之后，在服务列表里面找到 Redis。</p><h3 id="Redis-启动和关闭"><a href="#Redis-启动和关闭" class="headerlink" title="Redis 启动和关闭"></a>Redis 启动和关闭</h3><p>安装好之后，我们可以通过服务启动和关闭 Redis 了，我们可以查看系统的任务管理器，检查是否启动了 redis-server，下面是 redis-server 的启动和关闭命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe  --service-start <span class="comment"># 启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe  --service-stop <span class="comment"># 关闭</span></span></span><br></pre></td></tr></table></figure><h3 id="使用-cli"><a href="#使用-cli" class="headerlink" title="使用 cli"></a>使用 cli</h3><p>确认 redis-server 启动之后，我们可以执行 redis 目录里面的 redis-cli.exe 文件，这样就可以连接上 Redis 了。当然，我们也可以通过命令行 CMD 来链接 Redis。</p><p>可以直接进行 Redis 存取了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli.exe -h 127.0.0.1 -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; set firstKey "moyufed"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get firstKey</span><br><span class="line">"moyufed"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="增加密码"><a href="#增加密码" class="headerlink" title="增加密码"></a>增加密码</h3><p>在 Redis 的安装目录中，有 redis.windows.conf 、redis.windows-service.conf 两个文件，我们使用记事本打开（推荐Notepad++），找到需要设置密码的行，可以 Ctrl + F 查找 <code>“requirepass”</code> 的所在的行，分别设置 Redis 密码（去掉前面的 <code>#</code>），例子：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass moyufed</span><br></pre></td></tr></table></figure><p></p><h3 id="使用-Redis"><a href="#使用-Redis" class="headerlink" title="使用 Redis"></a>使用 Redis</h3><p>修改好之后重启 redis-server ，此时连接 Redis 之后进行 Redis 存取需要登录，例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Administrator@WIN-1706081829 C:\Users\Administrator</span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe  --service-stop</span></span><br><span class="line">[42636] 25 Feb 18:42:53.622 # Redis service successfully stopped.</span><br><span class="line"></span><br><span class="line">Administrator@WIN-1706081829 C:\Users\Administrator</span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server.exe  --service-start</span></span><br><span class="line">[38828] 25 Feb 18:42:58.576 # Redis service successfully started.</span><br><span class="line"></span><br><span class="line">Administrator@WIN-1706081829 C:\Users\Administrator</span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli.exe -h 127.0.0.1 -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; set firstKey "moyufed"</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth moyufed</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set firstKey "moyufed"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get firstKey</span><br><span class="line">"moyufed"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>Window配置Redis环境和简单使用：<a href="https://www.cnblogs.com/wxjnew/p/9160855.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxjnew/p/9160855.html</a><br>Windows下Redis安装配置和使用注意事项：<a href="https://www.cnblogs.com/LMJBlogs/p/11550170.html" target="_blank" rel="noopener">https://www.cnblogs.com/LMJBlogs/p/11550170.html</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/10/01/【前端开发日常-4】Windows安装Redis及简单使用/" data-id="ckfp6614i000jewvyo3fas63u" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/全栈/">全栈</a></li></ul></footer></div></article><article id="post-Koa中间件使用之koa-router" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/28/Koa中间件使用之koa-router/" class="article-date"><time datetime="2020-09-27T19:51:00.000Z" itemprop="datePublished">2020-09-27</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/28/Koa中间件使用之koa-router/">Koa中间件使用之koa-router</a></h1></header><div class="article-entry" itemprop="articleBody"><p><a href="https://github.com/ZijianHe/koa-router" target="_blank" rel="noopener">Koa-router</a> 是 koa 的一个路由中间件，它可以将请求的URL和方法（如：<code>GET</code> 、 <code>POST</code> 、 <code>PUT</code> 、 <code>DELETE</code> 等） 匹配到对应的响应程序或页面。本文将介绍 koa-router 基本配置、使用以及一些参考笔记。</p><p class="article-more-link"><a href="/2020/09/28/Koa中间件使用之koa-router/#more">更多</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/28/Koa中间件使用之koa-router/" data-id="ckfp6615o001gewvycyckt64s" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/全栈/">全栈</a></li></ul></footer></div></article><article id="post-【前端开发日常-7】简单粗暴，在React中快速使用Mobx" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/18/【前端开发日常-7】简单粗暴，在React中快速使用Mobx/" class="article-date"><time datetime="2020-09-18T01:05:33.000Z" itemprop="datePublished">2020-09-17</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/18/【前端开发日常-7】简单粗暴，在React中快速使用Mobx/">【前端开发日常 - 7】简单粗暴，在React中快速使用Mobx</a></h1></header><div class="article-entry" itemprop="articleBody"><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>最近在做 React 项目，是一个简单的编辑页，刚开始没有考虑到复杂的场景，随着新的想法加入，现在需要增加多个页面，因此使用了 react-router ，为了在每个页面之间共享数据，实现状态管理，决定在项目中加入 Mobx 。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、安装 mobx 和 mobx-react ；<br>2、创建 store 并且使用 ；<br>3、使用@装饰器，在 <a href="http://moyufed.com/2020/09/17/%E3%80%90%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8-3%E3%80%91%E8%AE%A9create-react-app%E6%94%AF%E6%8C%81-%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">【前端开发日常 - 3】让create-react-app支持@装饰器语法</a> 文章中有介绍。</p><p class="article-more-link"><a href="/2020/09/18/【前端开发日常-7】简单粗暴，在React中快速使用Mobx/#more">更多</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/18/【前端开发日常-7】简单粗暴，在React中快速使用Mobx/" data-id="ckfp6614l000kewvypfc41q6l" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-【前端开发日常-3】让create-react-app支持-装饰器语法" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/" class="article-date"><time datetime="2020-09-17T00:52:39.000Z" itemprop="datePublished">2020-09-16</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/">【前端开发日常 - 3】让create-react-app支持@装饰器语法</a></h1></header><div class="article-entry" itemprop="articleBody"><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>目前在做的一个 react 项目是使用 <code>create-react-app</code> 创建的，我需要在里面使用 <code>mobx</code> 和 <code>mobx-react</code> 管理状态，<code>mobx-react</code> 支持使用装饰器的方式来书写，而 <code>create-react-app</code> 目前还没有内置的装饰器支持，所以在启动项目时会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Support for the experimental syntax 'decorators-legacy' isn't currently enabled</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener"><code>react-app-rewired</code></a> 修改 <code>create-react-app</code> 的配置，使其支持装饰器语法。</p><blockquote><p>此工具可以在不 ‘eject’ 也不创建额外 react-scripts 的情况下修改 create-react-app 内置的 webpack 配置，然后你将拥有 create-react-app 的一切特性，且可以根据你的需要去配置 webpack 的 plugins, loaders 等。</p></blockquote><p class="article-more-link"><a href="/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/#more">更多</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/" data-id="ckfp6614g000hewvylxspjgjn" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-通过rel-preload进行内容预加载" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/14/通过rel-preload进行内容预加载/" class="article-date"><time datetime="2020-09-14T07:14:07.000Z" itemprop="datePublished">2020-09-13</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/14/通过rel-preload进行内容预加载/">通过rel=preload进行内容预加载</a></h1></header><div class="article-entry" itemprop="articleBody"><p>更多详情可以参考，参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener">MDN文档</a> 。</p><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>最近遇到的问题：</p><ul><li>一个页面加载主要逻辑 <code>main.js</code> ，该文件很大，设计很多业务代码，并且依赖部分 JavaScript 插件，在 <code>main.js</code> 执行之前需要确保 JavaScript 插件加载完成。</li><li>需要确保 <code>main.js</code> 以较快的速度加载，不能因为 <code>js</code> 文件的加载顺序影响首页渲染时间。</li></ul><p class="article-more-link"><a href="/2020/09/14/通过rel-preload进行内容预加载/#more">更多</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/14/通过rel-preload进行内容预加载/" data-id="ckfp66151000wewvy72cew9h1" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-HTTP状态码参考" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/09/02/HTTP状态码参考/" class="article-date"><time datetime="2020-09-02T00:04:04.000Z" itemprop="datePublished">2020-09-01</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/09/02/HTTP状态码参考/">HTTP状态码参考</a></h1></header><div class="article-entry" itemprop="articleBody"><h3 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h3><table><thead><tr><th>已定义范围</th><th>分类</th><th></th></tr></thead><tbody><tr><td>1XX</td><td>100-101</td><td>信息提示</td></tr><tr><td>2XX</td><td>200-206</td><td>成功</td></tr><tr><td>3XX</td><td>300-305</td><td>重定向</td></tr><tr><td>4XX</td><td>400-415</td><td>客户端错误</td></tr><tr><td>5XX</td><td>500-505</td><td>服务器错误</td></tr></tbody></table><p class="article-more-link"><a href="/2020/09/02/HTTP状态码参考/#more">更多</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/09/02/HTTP状态码参考/" data-id="ckfp6615l001bewvychvb0aop" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/全栈/">全栈</a></li></ul></footer></div></article><article id="post-【前端开发日常-18】快速配置webpack开发环境" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/" class="article-date"><time datetime="2020-04-04T02:22:36.000Z" itemprop="datePublished">2020-04-03</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/">【前端开发日常 - 18】快速配置webpack开发环境</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line">v8.10.0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">5.6.0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> yarn -v</span></span><br><span class="line">1.13.0</span><br></pre></td></tr></table></figure><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir webpack-start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> webpack-start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm init</span></span><br></pre></td></tr></table></figure><p>根据提示输入项目信息，比如：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (webpack-start)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: 快速开始webpack开发</span><br><span class="line">entry point: (index.js) src/index.js</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords: webpack</span><br><span class="line">author: moyufed</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to F:\project\webpack-start\package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "name": "webpack-start",</span><br><span class="line">  "version": "1.0.0",</span><br><span class="line">  "description": "快速开始webpack开发",</span><br><span class="line">  "main": "src/index.js",</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "keywords": [</span><br><span class="line">    "webpack"</span><br><span class="line">  ],</span><br><span class="line">  "author": "moyufed",</span><br><span class="line">  "license": "ISC"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure><p></p><h2 id="安装-webpack-和-webpack-cli"><a href="#安装-webpack-和-webpack-cli" class="headerlink" title="安装 webpack 和 webpack-cli"></a>安装 webpack 和 webpack-cli</h2><p>现在都已经 0202 年，webpack已经是到了4的版本了，不再与webpack-cli放在同一个仓库，因此安装完 webpack 之后还需要安装 webpack-cli 搭配食用才会香。参考文章：<a href="https://stackoverflow.com/questions/49092291/the-cli-moved-into-a-separate-package-webpack-cli" target="_blank" rel="noopener">https://stackoverflow.com/questions/49092291/the-cli-moved-into-a-separate-package-webpack-cli</a></p><p class="article-more-link"><a href="/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/#more">更多</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/04/04/【前端开发日常-18】快速配置webpack开发环境/" data-id="ckfp6615j0019ewvydcmw6qru" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Webpack/">Webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-JavaScript的this关键字" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/03/31/JavaScript的this关键字/" class="article-date"><time datetime="2020-03-31T06:15:14.000Z" itemprop="datePublished">2020-03-30</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/03/31/JavaScript的this关键字/">JavaScript的this关键字</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="JavaScript的this关键字"><a href="#JavaScript的this关键字" class="headerlink" title="JavaScript的this关键字"></a>JavaScript的this关键字</h2><p><code>this</code> 关键字指向一个对象，该对象是JavaScript当前代码执行的小块。换而言之，每个JavaScript方法执行的时候都有一个执行上下文（execution context），就是我们的 this。执行上下文体现了当前方法是如何被调用的。</p><p>为了理解 <code>this</code> 关键字，我们首先要关注方法是何时、何处、以何种方式调用的，而不是关注方法在何处以何种方式声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">"Pulsar"</span>, <span class="attr">bike</span>: bike &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">"Gixxer"</span>, <span class="attr">bike</span>: bike &#125;;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Ninja"</span></span><br><span class="line">obj1.bike();      <span class="comment">// "Pulsar"</span></span><br><span class="line">obj2.bike();      <span class="comment">// "Gixxer"</span></span><br></pre></td></tr></table></figure><p>在上面的代码中， <code>bike()</code> 方法的作用就是打印 <code>this.name</code> ，也就是说打印出当前执行上下文的 <code>name</code> 属性的值。当 <code>bike()</code> 方法被调用时，打印出 “Ninja” ，因为在没有指定的情况下，执行上下文都会指向<strong>全局对象</strong>，而在全局对象上面，我们定义了一个 <code>name</code> 的属性，值是 “Ninja”。</p><p>同样的，在 <code>obj1().bike()</code> 中打印了 “Pulsar” ，因为 <code>bike()</code> 方法是以 <code>obj1</code> 作为执行上下文来调用的， <code>this.name</code> 实际上就是 <code>obj1.name</code> 。同理 <code>obj2.bike()</code> 方法的执行上下文就是 <code>obj2</code> 。</p><h2 id="This的默认绑定和隐式绑定"><a href="#This的默认绑定和隐式绑定" class="headerlink" title="This的默认绑定和隐式绑定"></a>This的默认绑定和隐式绑定</h2><p><strong>默认绑定：</strong>如果我们的代码是在严格模式（strict mode）下， <code>this</code> 的值就是 <code>undefined</code> ，否则， <code>this</code> 指代了<strong>全局对象</strong> 。</p><p>当单独使用时，它指的是<strong>全局对象</strong> ，浏览器中的<strong>全局对象</strong>其实就是 window 对象 [<strong>object Window</strong>] ，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>当在一个方法中使用，this指向全局对象，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：严格模式不允许默认绑定，所以 <code>this</code> 将会是 <code>undefined</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>隐式绑定：</strong>当使用一个对象的属性调用一个方法时，该对象就成了方法的执行上下文 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"Pulsar"</span>,</span><br><span class="line">  bike: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">"Gixxer"</span>, <span class="attr">bike</span>: obj1.bike &#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> bike = obj1.bike;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Ninja"</span></span><br><span class="line">obj1.bike();      <span class="comment">// "Pulsar"</span></span><br><span class="line">obj2.bike();      <span class="comment">// "Gixxer"</span></span><br></pre></td></tr></table></figure><p>上面的代码中，直接调用 <code>bike()</code> 就是默认绑定， <code>obj1.bike()</code> 和 <code>obj2.bike()</code> 就是隐式绑定。</p><p><code>bike</code> 方法是 <code>obj1</code> 的一个属性，但是当我们执行 <code>obj2.bike()</code> 时，执行上下文是 <code>obj2</code> ，因此<code>obj2.name</code> 的值被打印出来。</p><p>所以，清楚什么时间、什么地方、以何种方式调用方法是很重要的，而方法的声明并不影响。</p><h2 id="This的显式绑定和硬绑定"><a href="#This的显式绑定和硬绑定" class="headerlink" title="This的显式绑定和硬绑定"></a>This的显式绑定和硬绑定</h2><p><strong>显式绑定：</strong>如果我们使用 <code>call</code> 和 <code>apply</code> 来调用方法，那么方法将以第一个参数来作为它的执行上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"Pulsar"</span> &#125;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Ninja"</span></span><br><span class="line">bike.call(obj);   <span class="comment">// "Pulsar"</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们传递了一个对象 <code>obj</code> 作为 <code>call()</code> 的参数来调用 <code>bike</code> 方法，<code>obj</code> 就被指派到了 <code>this</code> ，输出<code>obj.name</code> 的值 “Pulsar” 。</p><p><strong>硬绑定：</strong>无论我们怎么调用方法，指定 <code>this</code> 对象始终不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bike = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">"Pulsar"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">"Gixxer"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> originalBikeFun = bike;</span><br><span class="line">bike = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  originalBikeFun.call(obj1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bike();           <span class="comment">// "Pulsar"</span></span><br><span class="line">bike.call(obj2);  <span class="comment">// "Pulsar"</span></span><br></pre></td></tr></table></figure><p>上面的代码中使用了<code>originalBikeFun.call(obj1);</code> ，使得 <code>bike()</code> 和 <code>bike.call(obj2)</code> 都输出<code>obj1.name</code> 的值。</p><h2 id="JavaScript中的new关键字"><a href="#JavaScript中的new关键字" class="headerlink" title="JavaScript中的new关键字"></a>JavaScript中的new关键字</h2><p>任何方法之前的 <code>new</code> 关键字会调用方法的 <code>constructor</code> ，然后产生下面的结果：</p><ul><li>产生一个新的空的对象；</li><li>该新对象关联到方法的 <code>prototype</code> 属性；</li><li>该新对象被绑定为 <code>this</code> 关键字，将作为方法的执行上下文；</li><li>如果方法没有返回任何值，那将隐性的返回 this 对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Ninja"</span>;</span><br><span class="line">  <span class="keyword">this</span>.maker = <span class="string">"Kawasaki"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" "</span> + maker);  <span class="comment">// undefined Bajaj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Pulsar"</span>;</span><br><span class="line"><span class="keyword">var</span> maker = <span class="string">"Bajaj"</span>;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> bike();</span><br><span class="line"><span class="built_in">console</span>.log(obj.maker);                  <span class="comment">// "Kawasaki"</span></span><br></pre></td></tr></table></figure><p>上面的代码中，<code>bike</code> 方法前面使用了 <code>new</code> ，因此它将创建一个新对象连接到 <code>bike</code> 方法的原型链, 然后该对象绑定到 <code>this</code> 从而被返回。因此返回的 <code>this</code> 对象被分配到 <code>obj</code> 然后<code>console.log(obj.maker)</code> 打印出 “Kawasaki” 。</p><p>同样是上面的代码，方法里面的 <code>this.name</code> 没有打印出 “Ninja” 或者 “Pulsar” ，反而是 <code>undefined</code> 。因为 <code>name</code> 是在方法里面被声明，和 <code>this.name</code> 是完全不同的。同样， <code>this.maker</code> 和 <code>maker</code> 也是不同的。</p><h2 id="This绑定顺序"><a href="#This绑定顺序" class="headerlink" title="This绑定顺序"></a>This绑定顺序</h2><ul><li>首先检查方法是否用 <code>new</code> 来调用;</li><li>然后检查方法是否是被 <code>call()</code> 或者 <code>apply()</code> 方法来调用;</li><li>其次检查方法是否是通过对象上下文来调用;</li><li>默认全局对象（严格模式是 <code>undefined</code> ）。</li></ul><p>原文链接：<a href="https://codeburst.io/all-about-this-and-new-keywords-in-javascript-38039f71780c" target="_blank" rel="noopener">https://codeburst.io/all-about-this-and-new-keywords-in-javascript-38039f71780c</a></p><p>参考链接：<a href="https://segmentfault.com/a/1190000004460913" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004460913</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/03/31/JavaScript的this关键字/" data-id="ckfp6613c0003ewvywmpk8431" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2020/03/31/File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）/" class="article-date"><time datetime="2020-03-31T06:13:32.000Z" itemprop="datePublished">2020-03-30</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2020/03/31/File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）/">File APIs（Blob, BlobURL, ArrayBuffer, FileReader）</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前的JavaScript很不擅长处理二进制数据，要将二进制数据保存在浏览器上使用需要牺牲1.3倍的存储空间（将数据转换成 <code>DataURI</code> ）。即使是使用 <code>XHR</code> 从服务器请求数据，将读入内存之后还需要转换成 <code>Base64</code> / <code>DataURI</code> ），过程十分繁琐。</p><p>但是，时代已经变了。</p><p>现在的JavaScript中，处理二进制数据已经不是难题。硬件和 JIT（just-in-time）编译器的升级，让H5实现大多数API来处理大容量的二进制数据。</p><p>下面来介绍HTML5的Blob, File, FileList等对象，以及它们之间的相互转换。</p><h2 id="HTML5的File-API和对象"><a href="#HTML5的File-API和对象" class="headerlink" title="HTML5的File API和对象"></a>HTML5的File API和对象</h2><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p>Blob可以更好的处理二进制数据和文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">    readonly size: UINT64 = <span class="number">0</span>,</span><br><span class="line">    readonly type: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(source:AnyArray, option:BlobTypeObject = null):Blob &#123; &#125;,</span><br><span class="line">    slice(start:INT64 = <span class="number">0</span>, <span class="attr">end</span>:INT64 = <span class="number">0</span>, <span class="attr">contentType</span>:<span class="built_in">String</span> = <span class="string">""</span>):Blob &#123; &#125;,</span><br><span class="line">    close():<span class="keyword">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobTypeObject</span> </span>&#123;</span><br><span class="line">    readonly type: <span class="built_in">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Blob具有 <code>size</code> 和 <code>type</code> 属性，并且还有 <code>slice</code> 和 <code>close</code> 方法，可以在 <code>ArrayBuffer</code> 或 <code>BlobURL</code> 之间相互转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([ <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> ]);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([ source ]);</span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(reader.result); <span class="comment">// reader.result 是 ArrayBuffer</span></span><br><span class="line">&#125;;</span><br><span class="line">reader.readAsArrayBuffer(blob);</span><br></pre></td></tr></table></figure><p>Blob构造器的第一参数指定一个数组，这个数组的元素类型可以是 <code>Blob</code> 、<code>ArrayBuffer</code> 、<code>TypedArray</code>、<code>String</code> 或 <code>Object</code> 。如果是 <code>Object</code> 的情况还需要用 <code>toString</code> 方法转换成字符串。如果有多个项的情况，将按照顺序链接Blob对象内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的Blob对象</span></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob();</span><br></pre></td></tr></table></figure><p>Blob的第二个参数指定了 <code>{ type: MimeTypeString }</code> ，<code>MimeTypeString</code> 设置了Blob的种类 <code>MimeType</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 octet-binary Blob 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer1 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> buffer2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([buffer1, buffer2], &#123; <span class="attr">type</span>: <span class="string">"application/octet-binary"</span> &#125;);</span><br></pre></td></tr></table></figure><p>通常使用二进制数据时会指定类型，如： <code>{ type: &quot;application/octet-binary&quot; }</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([file], &#123; <span class="attr">type</span>: <span class="string">"image/png"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([binary], &#123; <span class="attr">type</span>: <span class="string">"application/octet-binary"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">"字符串"</span>], &#123; <span class="attr">type</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">"&lt;html&gt;"</span>], &#123; <span class="attr">type</span>: <span class="string">"text/plain;charset=UTF-8"</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File继承了Blob对象。并且追加了Blob的 <code>{ name:String, lastModifiedDate:Date }</code> 属性，File 是 JavaScript 中少数处理本地文件方法的一种。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">    readonly name: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line">    readonly lastModifiedDate: <span class="built_in">Date</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly webkitRelativePath: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(source:Blob, fileName:String):File &#123; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Chrome中，File的构造器需要指定一个数组： <code>new File([], ...)</code> ，扩展了 <code>{ lastModified: Integer, webkitRelativePath: String }</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chrome的示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">    readonly name: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line">    readonly lastModified: Integer = <span class="number">0</span>,</span><br><span class="line">    readonly lastModifiedDate: <span class="built_in">Date</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly webkitRelativePath: <span class="built_in">String</span> = <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(source:AnyArray, fileName:String):File &#123; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于File继承了Blob，因此File也支持使用 <code>FileReader.readAsArrayBuffer()</code> API转换为Blob。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">reader.readAsArrayBuffer(file);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_toBlob</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.responseType = <span class="string">"blob"</span>;</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(xhr.response, url);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_toBlob(location.href, <span class="function"><span class="keyword">function</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> blobURL = URL.createObjectURL(blob);</span><br><span class="line">    <span class="keyword">var</span> file = <span class="keyword">new</span> File([blob], <span class="string">"foo.html"</span>); <span class="comment">// 或者是 new File(blob, ...)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="FileList"><a href="#FileList" class="headerlink" title="FileList"></a>FileList</h3><p><code>FileList</code> 是通过DOM如 <code>&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot;&gt;</code> 的 <code>onchange</code> 取得的File的列表。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[type="file"]'</span>).addEventListener(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileList = event.target.files; <span class="comment">// ArrayLikeObject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, iz = fileList.length; i &lt; iz; ++i) &#123;</span><br><span class="line">        <span class="keyword">var</span> file = fileList[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">    readonly length: UINT32 = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    item(index:UINT32):File &#123; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><code>FileReader</code> 类可以将二进制数据读入内存。</p><p>使用 <code>readAsArrayBuffer</code> 方法可以将 <code>Blob</code> 转换成 <code>ArrayBuffer</code> ，转换的结果通过 <code>result</code> 属性进行设置，同样可以使用 <code>readAsDataURL</code> 或 <code>readAsText</code> 等方法进行转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line">    EMPTY:   UINT16 = <span class="number">0</span>,</span><br><span class="line">    LOADING: UINT16 = <span class="number">1</span>,</span><br><span class="line">    DONE:    UINT16 = <span class="number">2</span>,</span><br><span class="line">    readonly error: <span class="built_in">Error</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly result: <span class="built_in">ArrayBuffer</span>|<span class="built_in">String</span> = <span class="literal">null</span>,</span><br><span class="line">    readonly readyState: UINT16 = EMPTY,</span><br><span class="line">    onload:      EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onloadstart: EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onloadend:   EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onprogress:  EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onabort:     EventHandler = <span class="literal">null</span>,</span><br><span class="line">    onerror:     EventHandler = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async read methods</span></span><br><span class="line">    readAsArrayBuffer(blob:Blob): <span class="keyword">void</span> &#123;&#125;,</span><br><span class="line">    readAsDataURL(blob:Blob):<span class="keyword">void</span> &#123;&#125;,</span><br><span class="line">    readAsText(blob:Blob, <span class="attr">label</span>:<span class="built_in">String</span> = <span class="string">""</span>):<span class="keyword">void</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    abort():<span class="keyword">void</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chrome中还有 <code>readAsBinaryString(blob:Blob):void {}</code> 方法。</p><h3 id="BlobURL生成和释放"><a href="#BlobURL生成和释放" class="headerlink" title="BlobURL生成和释放"></a>BlobURL生成和释放</h3><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p><code>BlobURL</code> 是 <code>blob:...</code> 的形式的假象URL，可以通过 <code>URL.createObjectURL(source:Blob):BlobURLString</code> 来动态生成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uint8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([uint8Array], &#123; <span class="attr">type</span>: <span class="string">"application/octet-binary"</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> blobURL = URL.createObjectURL(blob); <span class="comment">// "blob:http%3A//dev.w3.org/207c851d-7486-42ec-97b1-d3cd26d08ed9"</span></span><br></pre></td></tr></table></figure><p><code>URL.createObjectURL</code> 总是生成唯一的 <code>BlobURL</code> （对于同一个资源每次都会生成不同的URL），生成的 <code>BlobURL</code> 在浏览器关闭之前有效。</p><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>如果要释放BlobURL，可以调用 <code>URL.revokeObjectURL(blobURL:BlobURLString):void</code> 方法。当然，也有 <code>URL.createFor(Blob):BlobURLString</code> 创建可以自动释放的BlobURL，不过要考虑兼容性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blobURL = URL.createObjectURL(file);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">URL.revokeObjectURL(blobURL);</span><br></pre></td></tr></table></figure><p><code>img.src</code> 、 <code>XMLHttpRequest.open(method, URL)</code> 、<code>Audio</code> 等需要使用 URL 请求文件的情况，也可以通过生成BlobURL发送。</p><p>与DataURI时相比，使用BlobURL在速度和内存占用方面都更有优势，尤其是处理Audio等流式传输数据时，其差异会更明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">img.src = blobURL;</span><br></pre></td></tr></table></figure><p>Chrome可以通过访问chrome://blob-internals/来确认有效的BlobURL。</p><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><h3 id="Blob-File-BlobURL的相互转换"><a href="#Blob-File-BlobURL的相互转换" class="headerlink" title="Blob, File, BlobURL的相互转换"></a>Blob, File, BlobURL的相互转换</h3><p>BlobURL可以通过XMLHttpRequest转换成Blob或者ArrayBuffer等其它类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = xhr.response; <span class="comment">// ArrayBuffer</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.responseType = <span class="string">"arraybuffer"</span>;</span><br><span class="line"><span class="comment">//xhr.responseType = "blob";</span></span><br><span class="line">xhr.open(<span class="string">"GET"</span>, blobURL);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>Blob,，BlobURLString， ArrayBuffer的相互转换可以通过以下方法：</p><table><thead><tr><th style="text-align:left">原始</th><th style="text-align:left">目标</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">BlobURLString</td><td style="text-align:left">URL.createObjectURL(…)</td></tr><tr><td style="text-align:left">BlobURL</td><td style="text-align:left">Blob</td><td style="text-align:left">XMLHttpRequest#responseType = “blob”</td></tr><tr><td style="text-align:left">BlobURL</td><td style="text-align:left">ArrayBuffer</td><td style="text-align:left">XMLHttpRequest#responseType = “arraybuffer”</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">ArrayBuffer</td><td style="text-align:left">FileReader#readAsArrayBuffer(…)</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">BinaryString</td><td style="text-align:left">FileReader#readAsBinaryString(…)</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">DataURLString</td><td style="text-align:left">FileReader#readAsDataURL(…)</td></tr><tr><td style="text-align:left">Blob/File</td><td style="text-align:left">String</td><td style="text-align:left">FileReader#readAsText(…, 编码方式)</td></tr></tbody></table><p>转换ArryBuffer的方式可以如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_toArrayBuffer</span>(<span class="params">source,     <span class="regexp">//</span> @arg BlobURLString|URLString|Blob|File|TypedArray|ArrayBuffer</span></span></span><br><span class="line"><span class="function"><span class="params">                        callback</span>) </span>&#123; <span class="comment">// @arg Function - callback(result:ArrayBuffer, source:Any):void</span></span><br><span class="line">    <span class="keyword">if</span> (source.buffer) &#123;</span><br><span class="line">        <span class="comment">// TypedArray</span></span><br><span class="line">        callback(source.buffer, source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>) &#123;</span><br><span class="line">        <span class="comment">// ArrayBuffer</span></span><br><span class="line">        callback(source, source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Blob) &#123;</span><br><span class="line">        <span class="comment">// Blob or File</span></span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(reader.result, source);</span><br><span class="line">        &#125;;</span><br><span class="line">        reader.readAsArrayBuffer(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="comment">// BlobURLString or URLString</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.responseType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(xhr.response, source);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.open(<span class="string">"GET"</span>, source);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Unknown type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileReader#readAsText(blob, &quot;UTF-8&quot;)</code> 第二个参数可以指定编码方式，默认为 “UTF-8” ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = reader.result; <span class="comment">// String</span></span><br><span class="line">&#125;;</span><br><span class="line">reader.readAsText(file, <span class="string">"UTF-16"</span>);</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>《File APIs(Blob, BlobURL, ArrayBuffer, FileReader)》：<a href="https://qiita.com/TypoScript/items/0d5b08cecf959b8b822c" target="_blank" rel="noopener">https://qiita.com/TypoScript/items/0d5b08cecf959b8b822c</a></p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2020/03/31/File-APIs（Blob-BlobURL-ArrayBuffer-FileReader）/" data-id="ckfp66146000dewvyx9p0i7zy" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul></footer></div></article><article id="post-使用Taro开发一个微信小程序一" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2019/12/17/使用Taro开发一个微信小程序一/" class="article-date"><time datetime="2019-12-17T05:02:46.000Z" itemprop="datePublished">2019-12-16</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2019/12/17/使用Taro开发一个微信小程序一/">使用Taro开发一个微信小程序一</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="使用Taro开发一个微信小程序（一），小程序注册、项目创建"><a href="#使用Taro开发一个微信小程序（一），小程序注册、项目创建" class="headerlink" title="使用Taro开发一个微信小程序（一），小程序注册、项目创建"></a>使用Taro开发一个微信小程序（一），小程序注册、项目创建</h1><p>视频地址：<a href="https://www.bilibili.com/video/av76872374/" target="_blank" rel="noopener">https://www.bilibili.com/video/av76872374/</a></p><h3 id="为什么使用Taro"><a href="#为什么使用Taro" class="headerlink" title="为什么使用Taro"></a>为什么使用Taro</h3><ul><li>Taro是一个支持多端开发的框架，写一套代码可以编译成各主流小程序，并且包括H5和RN。</li><li>和React接轨，方便在React和Taro之间无缝切换，学习门槛不会太高。</li></ul><p>关于Taro技术选型，这里有一篇介绍，<a href="http://blog.moyufed.com/2019/11/23/Taro%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B8%8E%E6%9D%83%E8%A1%A1/">去查看</a> 。</p><h3 id="注册小程序"><a href="#注册小程序" class="headerlink" title="注册小程序"></a>注册小程序</h3><ol><li>注册小程序需要一个电子邮箱，然后进入<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a>，点击 【立即注册】。</li><li>进入到账号类型选择，点击【小程序】，注意，<strong>一个邮箱只能注册一个账号类型，这些账号可以关联到同一个微信号</strong> 。</li><li>完善注册信息，需要输入邮箱地址、密码并且确认密码，填入验证码之后点击【注册】。</li><li>注册之后，会提示验证邮箱，点击【登录邮箱】去到收件箱找到微信发送的邮件，点击详情里面的链接完成验证。</li><li>完善微信小程序主体信息，包括账号地区、主体类型（个人）、以及主体的信息，然后使用微信二维码扫描验证。</li><li>提交信息完成之后，即可点击【前往小程序】跳转到小程序管理页面，到这步，我们已经完成了小程序的注册。</li></ol><h3 id="下载安装微信开发工具"><a href="#下载安装微信开发工具" class="headerlink" title="下载安装微信开发工具"></a>下载安装微信开发工具</h3><p>在进行微信小程序开发的过程中，我们需要使用到微信开发工具，<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">点击进入</a>，我们可以选择自己喜欢的版本进行下载，下载完成之后双击执行安装，不多做介绍。</p><h3 id="下载Taro"><a href="#下载Taro" class="headerlink" title="下载Taro"></a>下载Taro</h3><p>详细详情，可以参考<a href="https://taro-docs.jd.com/taro/docs/GETTING-STARTED.html" target="_blank" rel="noopener">Taro文档</a> ，下面做要点介绍：</p><p>首先检查 <code>nodejs</code> 版本，打开命令行工具（本人使用 ConEmu ），在命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v8.<span class="number">10.0</span></span><br></pre></td></tr></table></figure><blockquote><p>Taro 项目基于 node，请确保已具备较新的 node 环境（&gt;=8.0.0），推荐使用 node 版本管理工具 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a> 来管理 node，这样不仅可以很方便地切换 node 版本，而且全局安装时候也不用加 sudo 了。</p></blockquote><p>关于 nvm 安装，这里有一个介绍视频，<a href="https://www.bilibili.com/video/av71367431/" target="_blank" rel="noopener">点击查看</a> 。接着执行命令安装Taro：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g @tarojs/cli</span><br></pre></td></tr></table></figure><p>为了避免我们在使用 <code>sass</code> 时出现安装安装错误，可以再全局安装<a href="https://www.npmjs.com/package/mirror-config-china" target="_blank" rel="noopener"><code>mirror-config-china</code></a>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g mirror-config-china</span><br></pre></td></tr></table></figure><p>安装完成之后，可以执行命令查看Taro的信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ taro info</span><br><span class="line">👽 Taro v1.<span class="number">3.25</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Taro CLI <span class="number">1.3</span>.<span class="number">25</span> environment info:</span><br><span class="line">    System:</span><br><span class="line">      OS: Windows <span class="number">10</span></span><br><span class="line">    Binaries:</span><br><span class="line">      Node: <span class="number">8.10</span>.<span class="number">0</span> - C:\Program Files\nodejs\node.EXE</span><br><span class="line">      Yarn: <span class="number">1.19</span>.<span class="number">1</span> - C:\Program Files (x86)\Yarn\bin\yarn.CMD</span><br><span class="line">      npm: <span class="number">5.6</span>.<span class="number">0</span> - C:\Program Files\nodejs\npm.CMD</span><br></pre></td></tr></table></figure><h3 id="创建第一个-Taro-项目"><a href="#创建第一个-Taro-项目" class="headerlink" title="创建第一个 Taro 项目"></a>创建第一个 Taro 项目</h3><p>执行命令创建项目：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ taro init 项目名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以本次实战项目为例</span></span><br><span class="line">$ taro init moyufed</span><br><span class="line">√ 拉取远程模板仓库成功！</span><br><span class="line">? 请输入项目名称！ moyufed</span><br><span class="line">? 请输入项目介绍！ 项目介绍</span><br><span class="line">? 是否需要使用 TypeScript ？ No</span><br><span class="line">? 请选择 CSS 预处理器（Sass/Less/Stylus） Sass</span><br><span class="line">? 请选择模板 mobx</span><br></pre></td></tr></table></figure><p>执行 <code>init</code> 之后，Taro 会自动执行依赖的安装。如果执行安装失败，我们可以按 ctrl+c 结束，手动执行命令安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yarn 安装依赖</span></span><br><span class="line">$ yarn install</span><br><span class="line"><span class="comment"># 或者使用 npm 安装依赖</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>执行命令启动：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yarn</span></span><br><span class="line">$ yarn dev:weapp</span><br><span class="line">$ yarn build:weapp</span><br><span class="line"><span class="comment"># 使用 npm script</span></span><br><span class="line">$ npm run dev:weapp</span><br><span class="line">$ npm run build:weapp</span><br></pre></td></tr></table></figure><h3 id="运行和预览"><a href="#运行和预览" class="headerlink" title="运行和预览"></a>运行和预览</h3><p>打开已经下载安装好的微信开发工具，用自己的微信扫描登录。然后进入项目目录，执行命令启动dev ：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yarn</span></span><br><span class="line">$ yarn dev:weapp</span><br><span class="line"><span class="comment"># 使用 npm script</span></span><br><span class="line">$ npm run dev:weapp</span><br></pre></td></tr></table></figure><p>为了能够使用刚注册好的小程序进行预览，先去完善小程序信息：</p><ol><li>进入微信公众平台小程序首页，点击小程序信息栏目的【填写】前往信息完善页面，完善和提交小程序信息之后，点击右侧【开发】菜单，选择【开发设置】标签，可以看到小程序ID，复制小程序ID，填入项目根目录的 <code>project.config.json</code> ，修改<code>appid</code> 的值为小程序的ID。</li><li>在小程序开发工具中，点击新建小程序，选择【导入项目】，下拉选择我们创建的小程序项目根文件夹，点击【导入】，这时我们就可以边修改代码边查看小程序效果了。</li></ol><p>更多详情，可以点击文章开头的视频连接查看。</p></div><footer class="article-footer"><a data-url="http://blog.moyufed.com/2019/12/17/使用Taro开发一个微信小程序一/" data-id="ckfp6614s000pewvy72fns5p4" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/">Nodejs</a></li></ul></footer></div></article><nav id="page-nav"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a></nav></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongodb/">Mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全栈/">全栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/Linux/" style="font-size:10px">Linux</a> <a href="/tags/Mongodb/" style="font-size:10px">Mongodb</a> <a href="/tags/Nodejs/" style="font-size:15px">Nodejs</a> <a href="/tags/React/" style="font-size:15px">React</a> <a href="/tags/Webpack/" style="font-size:10px">Webpack</a> <a href="/tags/全栈/" style="font-size:15px">全栈</a> <a href="/tags/前端/" style="font-size:20px">前端</a></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul><li><a href="/2020/10/01/【前端开发日常-4】Windows安装Redis及简单使用/">【前端开发日常 - 4】Windows安装Redis及简单使用</a></li><li><a href="/2020/09/28/Koa中间件使用之koa-router/">Koa中间件使用之koa-router</a></li><li><a href="/2020/09/18/【前端开发日常-7】简单粗暴，在React中快速使用Mobx/">【前端开发日常 - 7】简单粗暴，在React中快速使用Mobx</a></li><li><a href="/2020/09/17/【前端开发日常-3】让create-react-app支持-装饰器语法/">【前端开发日常 - 3】让create-react-app支持@装饰器语法</a></li><li><a href="/2020/09/14/通过rel-preload进行内容预加载/">通过rel=preload进行内容预加载</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2020 摸鱼前端 | Moyufed<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><br><a href="http://www.beian.miit.gov.cn" target="_blank">黔ICP备18007258号</a></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives" class="mobile-nav-link">Archives</a></nav><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body>